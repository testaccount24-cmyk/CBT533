//TESTVTT2 JOB (Z904,0012),'GERHARD',CLASS=E,MSGCLASS=C,
//             MSGLEVEL=(1,1),
//             TIME=2,REGION=4096K
//*
//        EXEC PURGEME
//*
//       EXEC  ASMXTEST,PARM.G=
//U.SYSIN  DD  *
./       ADD   NAME=AMODE
         MACRO ,
         AMODE ,
.*   DUMMY MACRO CREATED TO SUPPORT ASSEMBLY UNDER HERCULES (XF ASM)
         MEND  ,
./       ADD   NAME=RMODE
         MACRO ,
         RMODE ,
.*   DUMMY MACRO CREATED TO SUPPORT ASSEMBLY UNDER HERCULES (XF ASM)
         MEND  ,
./       ADD   NAME=VTT2TAPE
   TITLE 'VTT2TAPE -- COPY AWS FORMAT FILE TO A REAL TAPE'
**************************************************************
**************************************************************
**                                                          **
**                                                          **
**  MODULE: VTT2TAPE.   Written by Sam Golob                **
**                                                          **
**       Copyright (c) 2001-2005 by Sam Golob               **
**                                                          **
**       A component of the:                                **
**       Virtual Tape Transportation System (VTTS)          **
**                                                          **
**  PURPOSE:  Program to process P390 and FLEX-ES MVS       **
**            Virtual Tape data in AWS format.  This data   **
**            is uploaded to an MVS system as an FB-80      **
**     card-image file.  The receiving MVS system does      **
**     not have to be able to handle AWS-format virtual     **
**     tapes, but it can use this program to read the tape  **
**     data from this folded AWS-format file, and create    **
**     a real tape from it.                                 **
**                                                          **
**     The OS2 or PC AWS-format tape file that was created  **
**     by the P390 or FLEX-ES system as a virtual tape, is  **
**     uploaded to the MVS system as an FB-80 card-image    **
**     file, with its (continuous stream of) data folded    **
**     over into 80-byte records, that can be blocked on    **
**     MVS.  This VTT2TAPE program reads the resulting      **
**     file, and creates a real output tape using EXCP, on  **
**     a real tape drive, by filling a buffer and writing   **
**     out its contents to the real tape.                   **
**                                                          **
**     This program is designed to also take input from     **
**     the FB-80 AWS-format output file, which is produced  **
**     by the VTT2DISK program.  These two programs,        **
**     VTT2TAPE and VTT2DISK, are designed to work          **
**     together, as paired and opposite programs.           **
**                                                          **
**  METHOD:                                                 **
**                                                          **
**     1.  Since all the tape data is folded into 80-byte   **
**         record segments, these have to be logically      **
**         strung together, to be able to correctly write   **
**         the tape data to tape blocks.                    **
**                                                          **
**     2.  First, the program has to correctly jump from    **
**         one AWS header record to the next, and so        **
**         proceed through all the headers in the entire    **
**         tape file, not missing any.  Diagnostic output   **
**         from this process, is written to the optional    **
**         SYSTRACE ddname, if it is present in the         **
**         execution JCL (see below).                       **
**                                                          **
**         The first header of an AWS-format tape is the    **
**         first six bytes of the file.  Once you have      **
**         the first header, you have the number of bytes   **
**         of data until the next header, and so forth.     **
**                                                          **
**         The UNFOLDEM called program unfolds the data     **
**         from a chunk of data after an AWS header, and    **
**         strings it out into an output buffer, after      **
**         which an EXCP operation writes the entire        **
**         buffer to tape.  If a block of data is from      **
**         several chunks, the data pieces are all strung   **
**         out into the output buffer, and then at the      **
**         end of the block (flag X'20' in the header),     **
**         all of the buffer data is written out to tape.   **
**                                                          **
**     3.  In the process of jumping from one header to     **
**         another, the program then moves the correct      **
**         number of data bytes that are in between the     **
**         headers, into the output buffer, 80-bytes or     **
**         less, at a time.  This action depends on the     **
**         type of header that we have.                     **
**                                                          **
**           HEADER TYPE       ACTION                       **
**           ------ ----       ------                       **
**           X'80'             Initialize buffer address.   **
**                             Write chunk of data to       **
**                              the buffer.                 **
**                                                          **
**           X'00'             Write another chunk of data  **
**                              to the end of the previous  **
**                              chunk in the buffer.        **
**                                                          **
**           X'20'             Add the chunk of data to     **
**                              the buffer.                 **
**                             Write out the entire buffer. **
**                             Initialize the start of      **
**                              buffer address.             **
**                                                          **
**           X'A0'             X'80' and X'20' combined.    **
**                                                          **
**           X'40'             Write a tape mark.           **
**                             Finalize the tape file.      **
**                             Initialize the output buffer **
**                              location.                   **
**                                                          **
**  Note:  If the output tape is too short, VTT2TAPE        **
**         attempts to recover by issuing an EOV macro,     **
**         which calls for a mount of a second tape,        **
**         as a PRIVATE SCRATCH tape.  More data from the   **
**         AWS file is written out to the second tape.      **
**                                                          **
**         However, there is a catch here.  The second      **
**         tape does not contain additional labels, as      **
**         DFP would have written.  The second tape         **
**         continues with the next block of data, after     **
**         the last block which was successfully written    **
**         to the first tape.                               **
**                                                          **
**         Therefore, in order to subsequently read the     **
**         second tape, you have to treat both tapes as     **
**         two-volume BLP, using JCL similar to this,       **
**         even if the first tape is SL...                  **
**                                                          **
**       //TAPOUT    DD  DISP=OLD,UNIT=TAPE,                **
**       //          VOL=(,RETAIN,SER=(VOL001,VOL002,etc)), **
**       //          LABEL=(n,BLP,EXPDT=98000)              **
**                                                          **
**         where n (for BLP) would be 3m-1 (where m is      **
**         the SL file number).                             **
**                                                          **
**         Sorry for that.  The reason is because this      **
**         program writes tape blocks using EXCP, and       **
**         for the second volume, I'd have to manufacture   **
**         my own tape labels, and I haven't added such     **
**         an enhancement at this time.  If BSAM or QSAM    **
**         created a second SL tape, then the extra EOV     **
**         and VOL and HDR labels are created by DFP.       **
**         EXCP contains no such provisions, leaving any    **
**         extra label creation entirely up to the          **
**         programmer.                                      **
**                                                          **
**                                                          **
**  OPTIONAL DDNAMES:                                       **
**                                                          **
**         In order to make sure that the VTT2TAPE program  **
**         is doing its job properly, it produces a lot of  **
**         trace data and status data, as it is reading     **
**         through the folded FB-80 AWS format tape.  In    **
**         order not to clutter the summary report, most    **
**         of this data is written to "Optional DDNAMEs".   **
**                                                          **
**         Optional DDNAMEs don't have to be coded in the   **
**         JCL.  But if they are coded, they will contain   **
**         the extra trace data which VTT2TAPE produces.    **
**                                                          **
**         The optional DDNAMEs are SYSFILES, SYSTRACE,     **
**         SYSMOVED, and SYSIN.                             **
**                                                          **
**         Full JCL to run the VTT2TAPE program is as       **
**         follows:                                         **
**                                                          **
**         (But you can code PARM=READ, or                  **
**            PARM='TVOL(volser)'       or                  **
**            PARM='TVOL=volser'              )             **
**                                                          **
**         If you code, PARM='TVOL.....' to override the    **
**         volser of the new tape, this may be further      **
**         overridden by the SYSIN card:  NEWVOL=volser.    **
**                                                          **
**       //   jobcard                                       **
**       //AWSREAD  EXEC PGM=VTT2TAPE                       **
**       //STEPLIB   DD  DISP=SHR,DSN=your.load.library     **
**       //AWSIN     DD  DISP=SHR,DSN=folded.aws.file,      **
**                   DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)  **
**       //TAPOUT    DD  DISP=OLD,UNIT=582,VOL=SER=TEST01,  **
**       //          LABEL=(1,BLP,EXPDT=98000)              **
**       //SYSPRINT  DD  SYSOUT=*                           **
**       //SYSFILES  DD  SYSOUT=*                           **
**       //SYSTRACE  DD  SYSOUT=*                           **
**       //SYSMOVED  DD  SYSOUT=*                           **
**       //SYSUDUMP  DD  SYSOUT=*                           **
**       //SYSIN     DD  *                                  **
**       NEWVOL=PROD01                                      **
**       /*                                                 **
**       //                                                 **
**                                                          **
**         where you can leave out SYSTRACE, SYSMOVED,      **
**         and SYSUDUMP, if you want to.  I'd strongly      **
**         suggest including (at least) SYSFILES, though.   **
**                                                          **
**         If you code NEWVOL=volser in a //SYSIN card,     **
**         starting in column 1, VTT2TAPE will change       **
**         the VOLSER in every VOL1 label (should only be   **
**         one of them) on the tape, to the value you       **
**         specify.                                         **
**                                                          **
**         SYSFILES gives you block counts and byte counts  **
**         for all files read and written.  SYSFILES also   **
**         differentiates between label files and data      **
**         files.                                           **
**                                                          **
**         SYSTRACE tells you if you are running through    **
**         all the AWS headers properly.  SYSMOVED tells    **
**         you how many bytes were moved from each chunk    **
**         of data between AWS headers.  SYSUDUMP is        **
**         there to contain the MVS-produced dump, upon     **
**         any abnormal termination of the program.         **
**                                                          **
**                                                          **
**  CHANGE LOG:                                             **
**                                                          **
**    Version 1.1 - Correct Operation of data moves from    **
**       the AWS file to the output buffer, and produce     **
**       traces to debug this.  SYSMOVED ddname.            **
**                                                          **
**    Version 1.2 - Add byte counts and SYSFILES ddname.    **
**       Fix AWSTAPE emulator problem when writing a        **
**       tape mark.  OS/2 AWSTAPE emulator cares what       **
**       the byte count is in CCW+6, even if the opcode     **
**       is X'1F'.  Made sure the byte count is always 0    **
**       when doing EXCP with a "write tape mark" opcode.   **
**                                                          **
**    Version 1.3 - Check for error conditions on output.   **
**       Put version number and assembly date into headers. **
**       Put cumulative byte totals in SYSFILES report.     **
**                                                          **
**    Version 1.4 - Differentiate between label files and   **
**       data files.  Different cumulative byte counts for  **
**       each.                                              **
**                                                          **
**    Version 1.5 - Better SYSFILES report upon volume      **
**       switch, if the first output tape is too short.     **
**       Pass null SL files.  Don't stop in the middle of   **
**       them, because of the two tape marks after the      **
**       HDR2.                                              **
**                                                          **
**    Version 1.6 - Block counts for each file and for the  **
**       entire tape.                                       **
**                                                          **
**    Version 1.7 - Allow PARM=READ, just to get stats.     **
**                                                          **
**    Version 1.8 - Make file-level stats reporting into    **
**       a subroutine.                                      **
**                                                          **
**    Version 1.9 - Header validation.  If a header is      **
**       corrupted, the chain of headers will be broken,    **
**       and we try to detect this and abort the program,   **
**       before any significant damage is done to the       **
**       output file.  We try and keep as much valid data   **
**       as possible in the output tape.  Add return code   **
**       indication of different error conditions.          **
**                                                          **
**    Version 1.9A - Better messages if this header's       **
**       previous byte value doesn't match the last         **
**       header's current byte value.  Pinpoint file and    **
**       block number in error.  Allow 4-byte version       **
**       number literal, in preparation for 1.10, etc.      **
**                                                          **
**    Version 1.10 -   Optional SYSIN dd name which can     **
**       contain a card:  NEWVOL=volser   starting in       **
**       column 1, which overrides the output tape's        **
**       volume serial.                                     **
**                                                          **
**    Version 1.11 -   INAREA now addressed indirectly.     **
**                                                          **
**    Version 1.12 -   Logic changed to accommodate chunks  **
**       of data between headers that are shorter than the  **
**       tape blocks.  Much of the program has been         **
**       completely rewritten.  Moves of data between AWS   **
**       headers to the output buffer, are now done only    **
**       by the UNFOLDEM called program.  The SYSFILES      **
**       report has been improved.  The SYSMOVED and        **
**       SYSTRACE reports now reflect the data associated   **
**       with each header encountered.                      **
**                                                          **
**    Version 1.13 -   Put in ASG enhancement to allow a    **
**       volser change through a PARM='TVOL=nwvser', or     **
**       PARM='TVOL(nwvser)'.  Put in a check for short     **
**       volsers (less than 6 characters) and ran the parm  **
**       for the volser through a translate table first,    **
**       to uppercase it and clean it up somewhat.  The     **
**       volser that is coded in the SYSIN DD card can      **
**       completely override this, so you still have the    **
**       freedom to create bizarre volsers if you really    **
**       want to.  BTW, you do not need to code the new     **
**       volser in the JCL.  This program does not do a     **
**       RDJFCB to find out what is in the JCL.             **
**                                                          **
**                                                          **
**  RETURN CODES:                                           **
**                                                          **
**    RC =  0 :    Normal Operation                         **
**                                                          **
**    RC =  4 :    A Private Scratch tape was asked for,    **
**                 because the end of the first output      **
**                 tape was reached.                        **
**                                                          **
**    RC =  8 :                                             **
**                                                          **
**    RC = 12 :    Program operation had to be aborted      **
**                 because the chain of AWS headers was     **
**                 broken in the middle, and an invalid     **
**                 "AWS header" was encountered.  The       **
**                 program writes out all valid tape        **
**                 blocks, and then stops action, with a    **
**                 message that indicates the problem,      **
**                 and the header found to be in error.     **
**                 The last tape block written, is the      **
**                 block before the last correct AWS        **
**                 header.  This condition probably         **
**                 occurred because an invalid AWS header   **
**                 "current length" made it impossible      **
**                 to find the next valid AWS header.       **
**                                                          **
**                                                          **
**    Please note that a higher return code will            **
**    supersede a lower return code, and that multiple      **
**    error conditions might exist, if there is a nonzero   **
**    return code higher than 4.  Look at the SYSFILES      **
**    report, and the other reports, to determine the       **
**    exact error(s) present.                               **
**                                                          **
**                                                          **
**************************************************************
         EJECT
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
.* ---------------------------------------------------------------  *
.*   This macro is used to display hex values in a printed report.
.* ---------------------------------------------------------------  *
&NAME    DS    0H
         ST    R4,SAVER4B
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAVER4B
         LM    15,1,HEXSAVE
         MEND
**************************************************************
         GBLC  &LLEV
&LLEV    SETC  '1.13'
**************************************************************
         EJECT
VTT2TAPE CSECT
*                           It is probably not necessary to run
*                           this program in 24-bit mode.  But
*                           it works when it is run that way.
VTT2TAPE AMODE 24
VTT2TAPE RMODE 24
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'VTT2TAPE - AWS FB-80 DISK FILE INPUT TO REAL TAPE - '
         DC    C'LEVEL '
SYSLEV   DC    C'&LLEV'
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME ',C'--- '
         DC    C'Copyright (c) 2001 by Sam Golob '
SAVEAREA DC    18F'0'
EYECATCH DS    0D                    ENSURE ALIGNMENT
         SAVE  (14,12)
         LR    R5,R1                 SAVE PARM POINTER
         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR
         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1                NEW SAVE AREA ADDRESS
         DROP  R15
* -----                              SET UP BASE REGISTERS
         USING VTT2TAPE,R12,R11,R10,R8
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LA    R8,4095(,R10)
         LA    R8,1(,R8)
         LR    R1,R5                 RESTORE PARM POINTER
*
         MVC   SVNEWVOL(6),=C'      '    MAKE SVNEWVOL BLANK
         L     R1,0(,R1)             Get PARM field
         CLC   =C'TVOL',2(R1)        Is it a Tape volume override?
         BNE   CHKREAD               No. Then check if "read only".
         MVC   CHKNWVOL(6),7(R1)     Yes. Move chars from PARM=TVOL.
         TR    CHKNWVOL(6),TRTBLPRT  Translate to clean this up some.
*
*  Code to guard against a short volser or leading blanks in the PARM.
* >> below
*
         STM   R2,R5,SAVR2T5         Save 4 registers
         LA    R3,CHKNWVOL           Load address of source field
         LA    R4,6                  Load limit of characters moved
         LA    R5,SVNEWVOL           Load address of target field
         LR    R2,R5                 Start address of target field
MVELOOP  DS    0H                    Guard against a short volser.
         CLI   0(R3),X'00'           Delimiter of hexzeros?
         BE    MVELEND               Yes, end the move.
         CLI   0(R3),C' '            Delimiter of blank?
         BE    MVELEND               Yes, end the move.
         CLI   0(R3),C')'            Delimiter of close paren?
         BE    MVELEND               Yes, end the move.
         MVC   0(1,R5),0(R3)         Move one character over.
         OI    FLAGNEWV,X'01'        Flag that volser needs change.
         LA    R3,1(,R3)             Bump source character.
         LA    R5,1(,R5)             Bump target character.
         BCT   R4,MVELOOP            Try again if before end.
MVELEND  DS    0H
         LM    R2,R5,SAVR2T5         Restore 4 registers
MOVEEND  DS    0H
*
* >> above
*  Code to guard against a short volser or leading blanks in the PARM.
*
* ----- >                            Parm = READ    <--- below
*    See code for PARM='TVOL=nwvser' which is above, in several places.
* ----- >
CHKREAD  CLC   =C'READ',2(R1)        Is it "READ" only?
         BNE   COPYTAPE              No. Default is to copy the tape.
         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.
COPYTAPE DS    0H
* ----- >                            Parm = READ    <--- above
*
         L     R15,=V(UNFOLDEM)      UNFOLDEM subprogram
         ST    R15,SVUNFOLD          Save its entry point
         L     R0,=A(INAREA)         Address of tape buffer
         ST    R0,SVINAREA           Store it away for later use.
***********************************************************************
* GET SYSTEM DATE AND TIME - A standard way to get date and time      *
***********************************************************************
         STM   R14,R2,SAVE1402
*NEW*    TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY
         TIME  DEC           OLD AND SLOW                       \
         STCM  R0,15,TIME                                       \
         OI    TIME+3,X'0F'
*NEW*    STCM  R1,15,DATE+1                                     \
*NEW*    OI    DATE+4,X'0F'
*NEW*    UNPK  DATED,DATE
*  INSERTION TO SUPPORT DATE IN MVS 3.8                         \
         ST    R1,DB+4       SAVE JULIAN DATE                   \
         CLI   DB+4,1        DID USER SUPPLY A CENTURY?         \
         BH    HAVECENT      YES                                \
         AP    DB+4(4),=P'1900000'  ELSE ADD IT IN              \
HAVECENT MVO   DB2,DB+4(2)   ISOLATE THE YEAR                   \
         XC    DB(6),DB      ISOLATE THE DAYS                   \
         CVB   R1,DB         CONVERT DAYS TO BINARY             \
         CVB   R2,DB2        CONVERT YEAR TO BINARY             \
         SLR   R0,R0         SET FOR NO LEAP DAY ADJUSTMENT     \
*  N.B.: THIS WORKS UNTIL 2099 ONLY                             \
         EX    R2,EXISLEAP   TEST FOR MULTIPLE OF FOUR          \
         BNZ   NOTALEAP      BRANCH IF NOT A LEAP YEAR          \
         CH    R1,=H'60'     ON, BEFORE, OR AFTER LEAP DAY?     \
         BL    NOTALEAP      BEFORE; TREAT NORMALLY             \
         BH    ONELESS       AFTER; ADJUST DAY                  \
         LA    R0,1          SET LEAP DAY ADJUSTMENT            \
ONELESS  BCTR  R1,0          ONE LESS TO FIX DAYS AFTER LEAP DAY\
NOTALEAP LA    R4,DATETABL   GET TABLE OF CUMULATIVE DAYS       \
         LR    R5,R4         SAVE                               \
FINDMON  CH    R1,2(,R4)     IN THIS MONTH?                     \
         BNH   FOUNDMON      YES; PROCESS                       \
         LA    R4,2(,R4)     INCREMENT                          \
         B     FINDMON       AND TRY AGAIN                      \
FOUNDMON SH    R1,0(,R4)     SUBTRACT DAYS IN PRIOR MONTHS      \
         AR    R1,R0         ADJUST 1 IF LEAP DAY               \
         LA    R4,2(,R4)     FINAGLE TO MAKE MONTH COME OUT RIGHT
         SR    R4,R5         GET OFFSET TO MONTH                \
         SRL   R4,1          GET MONTH (1-12)                   \
*  WE NOW HAVE FULL YEAR IN R2, MONTH IN R4, AND DAY IN R1      \
         MH    R4,=H'100'    SHIFT FOR EDIT                     \
         AR    R4,R1         ADD DAY: MMDD                      \
         MH    R4,=H'10000'  SHIFT FOR EDIT                     \
         AR    R4,R2         NOW HAVE MMDDYYYY                  \
         MH    R4,=H'10'     FINAGLE A LITTLE MORE              \
         CVD   R4,DB         MAKE PACKED AND SIGNED             \
         UNPK  DATED,DB      CONFORM TO *NEW* CODE              \
EXISLEAP TM    =X'03',*-*    MULTIPLE OF FOUR?                  \
         SPACE 1                                                \
         UNPK  TIMED,TIME
*                          FILL HEADDATE AREA WITH INFO TO REUSE
         MVC   HEADDATE(2),DATED
         MVI   HEADDATE+2,C'/'
         MVC   HEADDATE+3(2),DATED+2
         MVI   HEADDATE+5,C'/'
         MVC   HEADDATE+6(4),DATED+4
         MVC   HEADDATE+12(2),TIMED
         MVI   HEADDATE+14,C':'
         MVC   HEADDATE+15(2),TIMED+2
         MVI   HEADDATE+17,C':'
         MVC   HEADDATE+18(2),TIMED+4
         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time
         MVC   MESSAGE4+88(31),HEADDLIT      in the reports.
         MVC   MESSAGE5+88(31),HEADDLIT
         MVC   MESSAGE6+88(31),HEADDLIT
         LM    R14,R2,SAVE1402
***********************************************************************
         MVC   LEVDATE(8),SYSDAT
***********************************************************************
         MVC   MESSAGE1+61(21),LEVELLIT    Program level and
         MVC   MESSAGE4+61(21),LEVELLIT      assembly date
         MVC   MESSAGE5+61(21),LEVELLIT
         MVC   MESSAGE6+61(21),LEVELLIT
* ----------------------------------------------------------------- *
INITEM   DS    0H                    Initialize some constants and
         MVI   FLAGSYST,X'00'        No optional ddnames initially.
         ZAP   INHDRS,=P'0'          Count number of AWS headers
         ZAP   INTYPE1,=P'0'         Counts of Header Types
         ZAP   INTYPE2,=P'0'
         ZAP   INTYPE3,=P'0'
         ZAP   INTYPE4,=P'0'
         ZAP   INTYPE5,=P'0'
         ZAP   FILCOUNT,=P'0'        Initialize file counter
         MVC   DBIN(8),=D'0'         Initialize byte counters
         MVC   LBIN(8),=D'0'
         MVC   DAIN(8),=D'0'
         MVC   DAINF(8),=D'0'
         MVC   LBINF(8),=D'0'
         MVC   DBINF(8),=D'0'
         MVC   OURRC,=F'0'
         MVC   MAXRC,=F'0'
* ----------------------------------------------------------------- *
TIOTSCAN DS    0H             Determine the presence of Optional
*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES
* ----->                      and open them if there is JCL for them.
* ----------------------------------------------------------------- *
         L     R5,16          R5=CVT
         L     R5,0(,R5)      R5=TCB WORDS
         L     R5,4(,R5)      R5=MY TCB
         L     R5,12(,R5)     R5=TIOT
         LA    R5,24(,R5)     R5=FIRST DD ENTRY
TIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?
         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES
         CLC   4(8,R5),SYSTRACE+40  SYSTRACE DDNAME THERE?
         BNE   TIOTMOVD       NO
*DEBUG*  OI    FLAGSYST,X'01'       SHOW PRESENCE OF SYSTRACE DD
         B     TIOTNEXT       CONTINUE
TIOTMOVD CLC   4(8,R5),SYSMOVED+40
         BNE   TIOTFILE
         OI    FLAGSYST,X'02'       SHOW PRESENCE OF SYSMOVED DD
         B     TIOTNEXT
TIOTFILE CLC   4(8,R5),SYSFILES+40
         BNE   TIOTSYSN
         OI    FLAGSYST,X'04'       SHOW PRESENCE OF SYSFILES DD
         B     TIOTNEXT
TIOTSYSN CLC   4(8,R5),SYSIN+40
         BNE   TIOTNEXT
         OI    FLAGSYST,X'08'       SHOW PRESENCE OF SYSIN DD
         B     TIOTNEXT
TIOTNEXT SR    R3,R3
         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY
         AR    R5,R3          R5=NEXT DD ENTRY
         B     TIOTLOOP       GO CHECK IT
TIOTSEND DS    0H
***********************************************************************
*    Now OPEN the files and start the processing.
***********************************************************************
*---------------------------------------------------------------------*
* -------------- >>>>>>   Look for new output volume name - BELOW
         TM    FLAGSYST,X'08'       Is SYSIN there?
         BZ    NONSYSIN             No. Then can't open it.
         OPEN  (SYSIN,(INPUT))
SYSINLUP DS    0H
         GET   SYSIN,GETSYSIN
         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?
         BNE   SYSINLUP              No. Don't use this card.
         CLI   GETSYSIN+7,C' '       Is the next letter a blank?
         BE    SYSINLUP              Yes. Ignore this card.
         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.
         OI    FLAGNEWV,X'01'             And show a new volser here.
         B     NONSYSIN
SYSINEND DS    0H
         CLOSE SYSIN
NONSYSIN DS    0H
* -------------- >>>>>>   Look for new output volume name - ABOVE
*---------------------------------------------------------------------*
         OPEN  (AWSIN,(INPUT))
         OPEN  (SYSPRINT,(OUTPUT))
         TM    READFLAG,X'01'        Is this run READ ONLY?
         BO    NOTAPOPN              Yes. Don't OPEN output tape.
         OPEN  (TAPOUT,(OUTPUT))
NOTAPOPN DS    0H
         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?
         BNO   NOSYSTRC              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSTRACE,(OUTPUT))
         PUT   SYSTRACE,MESSAGE4
         MVC   PRTLINE,PRTLINE-1
         PUT   SYSTRACE,PRTLINE
*--->>
         TM    READFLAG,X'01'        If READ ONLY, print extra line.
         BZ    NOEXTRA4
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'
         PUT   SYSTRACE,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         PUT   SYSTRACE,PRTLINE
NOEXTRA4 DS    0H
         PUT   SYSTRACE,MESSAGE9
         PUT   SYSTRACE,MESSAG10
         MVC   PRTLINE,PRTLINE-1
         PUT   SYSTRACE,PRTLINE
         PUT   SYSTRACE,MESSAGE8
*--->>
NOSYSTRC DS    0H
         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?
         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSMOVED,(OUTPUT))
         PUT   SYSMOVED,MESSAGE5
         MVC   PRTLINE,PRTLINE-1
         PUT   SYSMOVED,PRTLINE
*--->>
         TM    READFLAG,X'01'        If READ ONLY, print extra line.
         BZ    NOEXTRA5
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'
         PUT   SYSMOVED,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         PUT   SYSMOVED,PRTLINE
NOEXTRA5 DS    0H
*--->>
NOSYSFIL DS    0H
         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?
         BNO   NOSYSMVD              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSFILES,(OUTPUT))
         PUT   SYSFILES,MESSAGE6
         MVC   PRTLINE,PRTLINE-1
         PUT   SYSFILES,PRTLINE
*--->>
         TM    READFLAG,X'01'        If READ ONLY, print extra line.
         BZ    NOEXTRA6
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'
         PUT   SYSFILES,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         PUT   SYSFILES,PRTLINE
NOEXTRA6 DS    0H
*--->>
NOSYSMVD DS    0H
* ----------------------------------------------------------------- *
*     Write the top Header Line, with the date and time in it.
* ----------------------------------------------------------------- *
         PUT   SYSPRINT,MESSAGE1
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
*--->>
         TM    READFLAG,X'01'        If READ ONLY, print extra line.
         BZ    NOEXTRA1
         MVC   PRTLINE,PRTLINE-1
         MVC   PRTLINE+4(21),=C'This Run is READ ONLY'
         PUT   SYSPRINT,PRTLINE
         MVC   PRTLINE,PRTLINE-1
         PUT   SYSPRINT,PRTLINE
NOEXTRA1 DS    0H
*--->>
* ----------------------------------------------------------------- *
*     Start trying to bop through the AWS headers.  The first 6
*     bytes of the file, is the first header, so we start there.
* ----------------------------------------------------------------- *
LOOPSTRT DS    0H                    START OF PROCESSING
         LA    R7,INCARD             INITIALIZE BEG OF RECORD
         ST    R7,SAVEBEGC           AND SAVE THIS SETTING.
* ---------------------------------------------------------------- *
         LA    R6,INCAEND            INITIALIZE END OF RECORD
         ST    R6,SAVEENDC           AND SAVE THIS SETTING.
         LA    R1,80(,R6)            BOP BY ANOTHER RECORD LENGTH
         ST    R1,SAVEEN80           AND SAVE WHERE THIS IS.
* ---------------------------------------------------------------- *
         GET   AWSIN,INCARD           Do the very first GET to find
*                                     the first header in the file.
*                                     The first header lets you find
*                                     all the other headers.
         AP    UNFINRCD,=P'1'         Update the control block too
         MVC   INHEADER(6),0(R7)      Got the first header
* ---------------------------------------------------------------- *
*     We come here when we know we're at the beginning of an
*     AWS header record.
* ---------------------------------------------------------------- *
GOTHEADR DS    0H                     Got a header record
* ---------------------------------------------------------------- *
         MVC   HDRPREVS(2),HDRPREV    SAVE PREVIOUS BLOCK SIZE
         MVC   HDRLENGS(2),HDRLENG    SAVE SIZE OF NEXT BLOCK
* ---------------------------------------------------------------- *
         AP    INHDRS,=P'1'           Count the number of headers.
         MVC   HEADER(6),INHEADER     Move header to formatting area.
*--->
         ST    R9,SAVER9HV            Save link register
         BAL   R9,VALIDHDR            Make sure header flags are valid
         L     R9,SAVER9HV            Restore link register
         TM    HDRVFLAG,X'01'         Is the header in error?
         BO    HEADRERR               Yes-report condition and end pgm.
*--->
*--->       Format the header by interpreting the length fields,
*--->       and then print the values for diagnosis if necessary.
*--->
*--->       HDRLENG contains the true halfword byte count of data
*--->               following this header.
*--->       HDRPREV contains the true halfword byte count of data
*--->               preceding this header.
*--->
*--->       In case fullword versions of these quantities are
*--->       needed, HDRFULLS and HDRPFULS are supplied too.
*--->
         MVC   SAVEHDR(6),HEADER      Save a copy of the current header
         MVC   HDRFILL(2),=X'0000'    Fill in zeros
         MVC   HDRPRVF(2),=X'0000'      for
         MVC   HDRLENFL(2),=X'0000'        fullword values
         MVC   HDRPRVFL(2),=X'0000'           of halfwords.
         MVC   HDRLENG+1(1),HDRCURLN     REVERSE
         MVC   HDRLENG(1),HDRCURLN+1        BYTES
         MVC   HDRPREV+1(1),HDRPRVLN     REVERSE
         MVC   HDRPREV(1),HDRPRVLN+1        BYTES
*
         MVC   PRTLINE,PRTLINE-1      CLEAR PRINT LINE
         HEX   PRTLINE+8,6,HEADER     UNFAREA at GOTHEADR time display
         HEX   PRTLINE+28,4,UNFSCARD                            .
         HEX   PRTLINE+38,4,UNFECARD                            .
         HEX   PRTLINE+48,4,UNFOFFST                            .
         HEX   PRTLINE+58,4,UNFBYTES                            .
         HEX   PRTLINE+68,4,UNFBYMVD                            .
         HEX   PRTLINE+78,4,UNFBUFFR                            .
         HEX   PRTLINE+88,4,UNFBSTRT                            .
         HEX   PRTLINE+98,7,UNFINRCD                            .
* ---------------------------------------------------------------- *
*              DETERMINE THE TYPE OF HEADER YOU HAVE
*                    AND COUNT HOW MANY OF EACH
* ---------------------------------------------------------------- *
KINDAHDR DS    0H
         CLI   HDRFLAG1,X'00'         IS THIS A MIDDLE CHUNK IN BLOCK?
         BNE   KCHKBEG                NO. TEST IF BEG CHUNK OF BLOCK
         AP    INTYPE3,=P'1'          YES. COUNT THIS TYPE
         B     KINDAHEN               IF IT'S 00 IT'S NOT ANOTHER TYPE
KCHKBEG  DS    0H
         TM    HDRFLAG1,X'80'         BEGINNING OF BLOCK?
         BNO   KCHKEND                NO. CHECK FURTHER FOR END OF BLK.
         AP    INTYPE1,=P'1'          YES. COUNT THIS TYPE
KCHKEND  DS    0H
         TM    HDRFLAG1,X'20'         END OF BLOCK?
         BNO   KINDAH40               NO. CHECK IF END OF FILE
         AP    INTYPE2,=P'1'          YES. COUNT THIS TYPE
KINDAHA0 DS    0H
         CLI   HDRFLAG1,X'A0'         BOTH BEGINNING AND END OF BLOCK?
         BNE   KINDAH40               NO. TEST FOR EOF HEADER.
         AP    INTYPE5,=P'1'          YES. COUNT IT FOR REPORTING.
         B     KINDAHEN               AND DON'T TEST MORE BITS.
KINDAH40 DS    0H
         TM    HDRFLAG1,X'40'         END OF FILE HEADER?
         BNO   KINDAHEN               NO. NOT A TYPE THAT WE KNOW.
         AP    INTYPE4,=P'1'          YES. COUNT THIS TYPE
*
*     Invalid types were already caught by the VALIDHDR routine.
*
KINDAHEN DS    0H
         HEX   PRTLINE+22,1,HDRFLAG1                            .
         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?
         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION
         PUT   SYSTRACE,PRTLINE
NOSYSTR1 DS    0H
         CLC   SAVEHDR(6),EOTMARK     IS THE HEADER AN EOT MARK?
         BNE   NOFIN                  NO. DON'T STOP THE PROGRAM.
         NI    UNEXFLAG,FF-X'01'      TURN OFF UNIT EXCEPTION FLAG
         TM    FLAGHDRL,X'01'         YES. BUT TEST IF AFTER HDR 1 OR 2
         BO    NOFIN                  AFTER HDR1 OR HDR2, DON'T END PGM
         B     FIN                    OTHERWISE END THE PROGRAM.
NOFIN    DS    0H
*------------------------------>  Validate Header Quantities  <-- below
*
*   This validation checks if the bytes in the "previous" byte count
*   field match the byte count in the "forward" field of the previous
*   header.  If there is an error, it is reported now.
*
         CLC   HDRLENGS(2),HDRPREV    Is Prev Length = Last Current ?
         BE    HDRVALID               Yes. As it should be.
         MVC   OUTLINE,OUTLINE-1      No. Corrupted headers.
         MVC   OUTLINE,ERRMESS6       Write nasty message.
         MVI   OUTLINE+58,C'P'        Display prev hdr quantity.
         HEX   OUTLINE+60,2,HDRPREV
         MVI   OUTLINE+66,C'C'        Display last current hdr amount.
         HEX   OUTLINE+68,2,HDRLENGS
         ZAP   FERCOUNT,FILCOUNT      Get File number in error
         AP    FERCOUNT,=P'1'         By adding 1 to last valid file
         MVC   OUTLINE+77(4),=C'File'    Put literal into message
         MVC   OUTLINE+82(9),FILEPAT     Get file number in error
         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.
         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error
         AP    BLERRCNT,=P'1'         By adding 1 to last valid block
         MVC   OUTLINE+96(5),=C'Block'   Put literal into message
         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number
         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.
         MVC   OURRC(4),=F'12'        Set RC = 12
         CLC   MAXRC,OURRC            Is MAXRC higher?
         BH    SAXERC02               Yes. Keep it.
         MVC   MAXRC,OURRC            No.  Raise MAXRC to this one.
SAXERC02 DS    0H
         TM    FLAGSYST,X'01'         Write nastygram to SYSTRACE.
         BZ    NOERRX1
         PUT   SYSTRACE,OUTLINE
NOERRX1  DS    0H
         TM    FLAGSYST,X'02'         Write nastygram to SYSMOVED.
         BZ    NOERRX2
         PUT   SYSMOVED,OUTLINE
NOERRX2  DS    0H
         TM    FLAGSYST,X'04'         Write nastygram to SYSFILES.
         BZ    NOERRX4
         PUT   SYSFILES,OUTLINE
NOERRX4  DS    0H
         PUT   SYSPRINT,OUTLINE       Write nastygram to SYSPRINT.
*
*       Maybe think of ending the program operation here.
*       REPLACE REPLACE REPLACE REPLACE REPLACE REPLACE REPLACE
*
HDRVALID DS    0H
*------------------------------>  Validate Header Quantities  <-- above
*
*
* - - - - - - - >>>>>   End of Header Operations....
* - - - - - - - >>>>>   Now go move the data afterward.
* ---------------------------------------------------------------- *
*     At this point, we will begin moving the data that is after
*     the first header.  Future OFFSETs will be supplied by the
*     previous call to the UNFOLDEM program.
* ---------------------------------------------------------------- *
LOOKINIT DS    0H                Start looking for the data at the
*                                beginning of the AWSIN tape file.
         TM    INITFLAG,X'01'    Not the first time here?
         BO    LOOKIEND          Bypass initializations.
         OI    INITFLAG,X'01'    Do this only once for the entire tape.
         MVC   UNFOFFST,=F'6'    Initialize OFFSET to be just past
*                                the first header in the file.
         MVC   UNFBUFFR,UNFBSTRT  Init buffer loc to start of buffer
LOOKIEND DS    0H
* ---------------------------------------------------------------- *
MOVEDATA DS    0H                This is the call to UNFOLDEM.
*                                We fill in the necessary fields.
*
*    UNFOLDEM is only intended to move the data between the AWS
*    headers.  "After processing" is controlled by the flags in
*    the headers.  After each header is processed, we again point
*    to the data after the headers (if any) and call UNFOLDEM to
*    move it.
*
         MVC   PREVHDR,SAVEHDR     Copy of last header for action later
         MVC   UNFSCARD,SAVEBEGC   Beginning address of input card
         MVC   UNFECARD,SAVEENDC   End address of input card
         XC    UNFBYTES,UNFBYTES   Zero out fullword bytes to be moved
         MVC   UNFBYTES+2(2),HDRLENG   And move in halfword value
         L     R1,SVINAREA         Point to address of buffer
         ST    R1,UNFBSTRT         Store it in beginning buffer field
         TM    NOWRTFLG,X'01'      Continue data move in same buffer?
         BO    MOVEBUFF            Yes. Don't reinitialize in buffer.
         ST    R1,UNFBUFFR         Store it in current buffer field
MOVEBUFF DS    0H
*        MVC   LINE+1(8),=C'BEFCALL '
*        BAL   R9,UNFIMAGE
         LA    R1,UNFAREA          Point to UNFAREA control block
         L     R15,SVUNFOLD        Load entry point of UNFOLDEM pgm
         BALR  R14,R15             Call the program and move data.
         MVC   UNFAREA(UNFLENTH),0(R1)  Move modified UNFAREA to pgm
*        MVC   LINE+1(8),=C'AFTCALL '
*        BAL   R9,UNFIMAGE
* -- Test for call of LABELCHK -- >   below
*   We have just moved the bytes.  Now we check if the file is a label.
         NI    ISLBLFLG,FF-X'01'   Initially assume it's not a label.
         L     R1,UNFBYMVD         The number of bytes moved just now.
         C     R1,=X'00000050'     Was it exactly 80?
         BNE   NOLBLCHK            No. Assume it can't be a label.
         L     R1,UNFBSTRT         Grab address of data buffer.
         MVC   TESTLABL(80),0(R1)  Move 80 bytes to the testing area.
         BAL   R9,LABELCHK         Test to see if it is a label.
         TM    ISLBLFLG,X'01'      Is it a label?
         BZ    NOLBLCHK            No. Assume entire file is not labels
         OI    FILBLFLG,X'01'      Yes. Turn on label flag at the
*                                   file level.
NOLBLCHK DS    0H
* -- Test for call of LABELCHK -- >   above
* ---------------------------------------------------------------- *
         BAL   R9,AFTRMOVE       Housekeeping after the data move.
*        MVC   LINE+1(8),=C'AFTAFTR '
*        BAL   R9,UNFIMAGE
         BAL   R9,CHKHEADR       Get new header ready for handling.
*        MVC   LINE+1(8),=C'AFTCHKH '
*        BAL   R9,UNFIMAGE
         B     GOTHEADR          Assume you've got another header.
* ---------------------------------------------------------------- *
*          END OF INPUT AWS DATA                                   *
* ---------------------------------------------------------------- *
FIN      DS    0H                   PROGRAM EXIT ROUTINE
         BAL   R9,WRITTPMK          WRITE FINAL TAPE MARK
         B     AGLE                 Finish processing
* ---------------------------------------------------------------- *
HEADRERR DS    0H
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE,ERRMESS5
         HEX   OUTLINE+58,6,HEADER
         ZAP   FERCOUNT,FILCOUNT      Get File number in error
         AP    FERCOUNT,=P'1'         By adding 1 to last valid file
         ZAP   BLERRCNT,BLOCKCNT      Get Block number in error
         AP    BLERRCNT,=P'1'         By adding 1 to last valid block
         MVC   OUTLINE+77(4),=C'File'    Put literal into message
         MVC   OUTLINE+82(9),FILEPAT     Get file number in error
         ED    OUTLINE+82(9),FERCOUNT+3  And print it in message.
         MVC   OUTLINE+96(5),=C'Block'   Put literal into message
         MVC   OUTLINE+102(11),BLOKPAT   And print bad block number
         ED    OUTLINE+102(11),BLERRCNT+2   in the error message.
         MVC   OURRC(4),=F'12'    RC = 12 for header error.
         CLC   MAXRC,OURRC        Is MAXRC higher?
         BH    SAMERC02           Yes. Keep it.
         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.
SAMERC02 DS    0H
         TM    FLAGSYST,X'01'
         BZ    NOERR01
         PUT   SYSTRACE,OUTLINE
NOERR01  DS    0H
         TM    FLAGSYST,X'02'
         BZ    NOERR02
         PUT   SYSMOVED,OUTLINE
NOERR02  DS    0H
         TM    FLAGSYST,X'04'
         BZ    NOERR04
         PUT   SYSFILES,OUTLINE
NOERR04  DS    0H
         PUT   SYSPRINT,OUTLINE
* ---------------------------------------------------------------- *
AGLE     DS    0H                   Print the Summary Report
         BAL   R9,SUMMREPT
* ---------------------------------------------------------------- *
*     Close the files that were OPENed
* ---------------------------------------------------------------- *
         CLOSE AWSIN
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+6(7),=C'MaxRC ='
         HEX   OUTLINE+14,1,MAXRC+3
         CLC   MAXRC(4),=F'4'
         BNH   NOERRPRT
         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'
         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'
         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'
         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'
NOERRPRT DS    0H
         PUT   SYSPRINT,OUTLINE
         CLOSE SYSPRINT
         TM    READFLAG,X'01'       If READ ONLY, don't CLOSE tape.
         BO    NOTAPCLS
         CLOSE TAPOUT
NOTAPCLS DS    0H
         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?
         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSTRACE
SYSTRNOP DS    0H
         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?
         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSMOVED
SYSFILNO DS    0H
         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSFILES DDNAME?
         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSFILES,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+6(7),=C'MaxRC ='
         HEX   OUTLINE+14,1,MAXRC+3
         CLC   MAXRC(4),=F'0'
         BE    NOERRFIL
         MVC   OUTLINE+18(13),=C'<+> ERROR <+>'
         MVC   OUTLINE+33(13),=C'<+> ERROR <+>'
         MVC   OUTLINE+48(13),=C'<+> ERROR <+>'
         MVC   OUTLINE+63(13),=C'<+> ERROR <+>'
NOERRFIL DS    0H
         PUT   SYSFILES,OUTLINE
         CLOSE SYSFILES
SYSMVDNO DS    0H
FIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM
         L     R13,4(,R13)
         MVC   16(4,R13),MAXRC      Load Maximum Return Code
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
* ----------------------------------------------------------------- *
* ---       SUBROUTINES                                         --- *
* ----------------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
* --------------------------------------------------------- *
UNFIMAGE DS    0H                 Take a picture of the UNFAREA now.
         HEX   LINE+10,4,UNFSCARD    Starting card address.
         HEX   LINE+20,4,UNFECARD    Ending card address.
         HEX   LINE+30,4,UNFOFFST    Offset (starting and ending)
         HEX   LINE+40,4,UNFBYTES    Number of bytes to be moved.
         HEX   LINE+50,4,UNFBYMVD    Number of bytes that were moved.
         HEX   LINE+60,4,UNFBUFFR    Current start location in buffer.
         HEX   LINE+70,4,UNFBSTRT    Location of beginning of buffer.
         HEX   LINE+80,7,UNFINRCD    Number of GETs done to AWSIN file.
         PUT   SYSPRINT,LINE
         MVC   LINE,LINE-1           Clear LINE after PUT.
         BR    R9
* --------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
CHKHEADR DS    0H                 Position to the next header
*                                 The idea is to fill the INHEADER
*                                 field with the correct value.
         ST    R9,SAVER9CH        Save BAL register
         L     R1,UNFOFFST        New offset, returned from UNFOLDEM.
         C     R1,=F'74'          Bigger or equal to 74?
         BL    CHKHOFSL           No. Just copy header straight.
CHKHOFSH DS    0H                 Yes. Need to combine with next card.
         MVC   INCARDP,INCARD     Copy this card to prev 80 byte area.
         GET   AWSIN,INCARD       GET another card adjacent to previous
         AP    UNFINRCD,=P'1'     Update UNFAREA field too.
         LA    R7,INCARDP         Point to two consecutive cards.
         A     R7,UNFOFFST        Add the returned offset.
         MVC   INHEADER(6),0(R7)  Move the new header to staging area.
         LA    R7,6(,R7)          Bump R7 past the new header.
         S     R7,=A(INCARD)      Get new offset for next UNFOLDEM call
         ST    R7,UNFOFFST        Store it in the UNFAREA control block
         B     CHKHEND            Finish this processing.
CHKHOFSL DS    0H
         LA    R7,INCARD          < 74. Header is in original card.
         LA    R7,0(R1,R7)        Bump by offset - point to new header
         MVC   INHEADER(6),0(R7)  And move it to staging area.
         LA    R7,6(,R7)          Bump R7 past the new header.
         L     R1,=A(INCARD)      Address of current card
         SR    R7,R1              Get new offset for next UNFOLDEM call
         ST    R7,UNFOFFST        Store it in the UNFAREA control block
CHKHEND  DS    0H
         L     R9,SAVER9CH        Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
AFTRMOVE DS    0H                 After the move, we act on the
*                                 information from the previous
*                                 AWS header.
         ST    R9,SAVER9AF        Save BAL register
         NI    NOWRTFLG,FF-X'01'  Turn off flag initially
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
AFTTST40 DS    0H                 X'40' means END-OF-FILE
*                                 So we finish off the file-level stuff
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*   TEST TEST TEST:  CHECK IF THERE CAN BE A VALID X'4x'  -------
         CLI   PRVHFLGS,X'40'     Is there an end-of-file condition?
         BNE   AFTTSTA0           No. Do next test.
         BAL   R9,WRITTPMK        Yes. Write a tape mark.
         AP    FILCOUNT,=P'1'     Count number of files written.
         BAL   R9,REPTFILE        Report on this file in SYSFILES.
         ZAP   BLOCKCNT,=P'0'     Zero block count for next file
         ZAP   FILEBYTS,=P'0'     Zero bytes moved for next file
         NI    FILBLFLG,FF-X'01'  Turn off Label File indicator
         XC    DBINF,DBINF        Zero byte count at file level
         XC    DAINF,DAINF        Zero data bytes at file level
         XC    LBINF,LBINF        Zero label bytes at file level
** - SYSMOVED ->>    Record the number of files written  -  BELOW
         TM    FLAGSYST,X'02'     Is SYSMOVED here and open?
         BNO   AFTT40WM           No. Don't attempt a print.
         MVC   OUTLINE,OUTLINE-1         Clear line.
         MVC   OUTLINE,MESSAG12          Mark END-OF-FILE in SYSMOVED
         MVC   OUTLINE+38(9),FILEPAT     Move in edit pattern
         ED    OUTLINE+38(9),FILCOUNT+3  Tell which file number ended
         PUT   SYSMOVED,OUTLINE
AFTT40WM DS    0H
** - SYSMOVED ->>    Record the number of files written  -  ABOVE
*        MVC   LINE+1(8),=C'AFT-40: '
*        BAL   R9,UNFIMAGE
         B     AFTRMEND           No more processing after this.
*
AFTTSTA0 DS    0H                 X'A0' means beg and end of block
         CLI   PRVHFLGS,X'A0'     Is chunk equal block?
         BNE   AFTTST80           No. Test for first chunk in block.
         L     R1,BLOKBYTS        Increment
         A     R1,UNFBYMVD          total byte count
         ST    R1,BLOKBYTS            in this block, from chunk bytes.
         L     R1,FILEBYTS        Increment
         A     R1,UNFBYMVD          total file bytes
         ST    R1,FILEBYTS            in this block, from chunk bytes.
         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR
** ---------- >>
         XC    BLOKBYTS,BLOKBYTS  Zero bytes moved after write
         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too
*        MVC   LINE+1(8),=C'AFT-A0: '
*        BAL   R9,UNFIMAGE
         B     AFTRMEND
AFTTST80 DS    0H                 X'80' means beginning of block
         CLI   PRVHFLGS,X'80'     Beginning chunk of bigger block?
         BNE   AFTTST00           No. Do next test.
         OI    NOWRTFLG,X'01'     Must move buffer start location up
         L     R1,BLOKBYTS        Increment
         A     R1,UNFBYMVD          total byte count
         ST    R1,BLOKBYTS            in this block, from chunk bytes.
         L     R1,FILEBYTS        Increment
         A     R1,UNFBYMVD          total file bytes
         ST    R1,FILEBYTS            in this block, from chunk bytes.
** ---------- >>    Record the number of bytes written  -  BELOW
         TM    FLAGSYST,X'02'           SYSMOVED ddname present?
         BNO   AFTT80WM                 No, can't write data to it.
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE,MESSAG11         Only if chunk less than block
         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE
         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH
         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW
         PUT   SYSMOVED,OUTLINE
AFTT80WM DS    0H
** ---------- >>    Record the number of bytes written  -  ABOVE
*        MVC   LINE+1(8),=C'AFT-80: '
*        BAL   R9,UNFIMAGE
         B     AFTRMEND
AFTTST00 DS    0H                 X'00' means middle chunk of block
         CLI   PRVHFLGS,X'00'     Is this a middle chunk?
         BNE   AFTTST20           No. Try next test.
         OI    NOWRTFLG,X'01'     Must move buffer start location up
         L     R1,BLOKBYTS        Increment
         A     R1,UNFBYMVD          total byte count
         ST    R1,BLOKBYTS            in this block, from chunk bytes.
         L     R1,FILEBYTS        Increment
         A     R1,UNFBYMVD          total file bytes
         ST    R1,FILEBYTS            in this block, from chunk bytes.
** ---------- >>    Record the number of bytes written  -  BELOW
         TM    FLAGSYST,X'02'           SYSMOVED ddname present?
         BNO   AFTT00WM                 No, can't write data to it.
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE,MESSAG11         Only if chunk less than block
         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE
         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH
         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW
         PUT   SYSMOVED,OUTLINE
AFTT00WM DS    0H
** ---------- >>    Record the number of bytes written  -  ABOVE
*        MVC   LINE+1(8),=C'AFT-00: '
*        BAL   R9,UNFIMAGE
         B     AFTRMEND           Get out - not X'80' or X'20'
AFTTST20 DS    0H                 X'20' means last chunk of block
         CLI   PRVHFLGS,X'20'     Is end-of-block on?
         BNE   AFTRMERR           No. Must be error. Tested all types.
         L     R1,BLOKBYTS        Increment
         A     R1,UNFBYMVD          total byte count
         ST    R1,BLOKBYTS            in this block, from chunk bytes.
         L     R1,FILEBYTS        Increment
         A     R1,UNFBYMVD          total file bytes
         ST    R1,FILEBYTS            in this block, from chunk bytes.
         BAL   R9,WRITBUFF        Write buffer and reset UNFBUFFR
*                                 Byte stats accumulated by WRITBUFF
** ---------- >>    Record the number of bytes written  -  BELOW
         TM    FLAGSYST,X'02'           SYSMOVED ddname present?
         BNO   AFTT20WM                 No, can't write data to it.
         TM    BWRITFLG,X'01'           Already written MESSAGE3?
         BO    AFTT20NW                 Yes. Don't repeat info here.
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE,MESSAG11         Only if chunk less than block
         HEX   OUTLINE+34,4,UNFBYMVD    PRINT BYTES MOVED IN THIS MOVE
         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER MOVE LENGTH
         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT TOTAL BYTES TILL NOW
         PUT   SYSMOVED,OUTLINE
AFTT20NW DS    0H
         NI    BWRITFLG,FF-X'01'        Write MESSAG11 from here on.
AFTT20WM DS    0H
** ---------- >>    Record the number of bytes written  -  ABOVE
         XC    BLOKBYTS,BLOKBYTS  Zero byte count moved after write.
         XC    UNFBYMVD,UNFBYMVD  Zero bytes moved in control block too
*        MVC   LINE+1(8),=C'AFT-20: '
*        BAL   R9,UNFIMAGE
         B     AFTRMEND
AFTRMERR DS    0H                 Code any error handling here.
AFTRMEND DS    0H
         L     R9,SAVER9AF        Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
WRITBUFF DS    0H
         ST    R9,SAVER9WR        BAL register save for WRITBUFF
         TM    READFLAG,X'01'     READ ONLY run?
         BO    WRITREAD           Yes. Don't do the EXCP.
         LA    R1,TAPOUT          R1=address of current DCB
         ST    R1,OUTDCBPT        Put it in IOB
         MVC   OUTCCW+1(3),UNFBSTRT+1   PRIME OUTPUT CCW
         MVC   OUTCCW+6(2),BLOKBYTS+2    Move length of block
         MVI   OUTECB,X'00'       Initialize ECB
         EXCP  OUTIOB             Write out the buffer
         WAIT  ECB=OUTECB         Wait for write to complete
         CLI   OUTECB,X'7F'       Write completed normally?
         BNE   WRITBERR           No - error
WRITREAD DS    0H
         AP    BLOCKCNT,=P'1'     Block count for this file
         AP    BLOCKTOT,=P'1'     Block count for entire tape
         MVC   UNFBUFFR,UNFBSTRT  Reset buffer start in UNFAREA
         B     WRITBUFE           OK
WRITBERR DS    0H
* --- >  handle eov on output - below
         NI    UNEXFLAG,FF-X'01'  Clear bit on unit exception flag
         TM    OUTCSW+4,X'02'     Unit check?
         BO    OUTERUC            Yes. Handle it.
         TM    OUTCSW+4,X'01'     Unit exception on write?
         BZ    OUTERR1            No. Assume data check.
         OI    UNEXFLAG,X'01'     Flag that we have unit exception
         MVC   LINE,LINE-1        Clear output line
         MVC   LINE(133),OUTUNEX  Set unit exception error message
         B     OUTERR2
OUTERUC  MVC   LINE(133),OUTEQC   Set unit check error message
         B     OUTERR2            Continue
OUTERR1  DS    0H
         MVC   LINE(133),OUTDCK   Set data check error message
OUTERR2  DS    0H
         ST    R2,SAVER2E         Save Registers
         ST    R4,SAVER4E
         ST    R5,SAVER5E
         L     R2,OUTDCBPT        Load DCB address
         LH    R4,40(,R2)         R4=TIOT offset
         L     R5,16              R5=CVT
         L     R5,0(,R5)          R5=TCB words
         L     R5,4(,R5)          R5=My TCB
         L     R5,12(,R5)         R5=TIOT
         AR    R4,R5              R4=TIOT Entry for this output
         MVC   LINE+34(6),4(R4)   Move DDNAME to message
         L     R4,16(,R4)         R4=UCB for this output
         MVC   LINE+47(4),12(R4)  Move unit address to message
         MVC   LINE+60(6),36(R4)  Move VOLSER to message
         L     R2,SAVER2E         Restore Registers
         L     R4,SAVER4E
         L     R5,SAVER5E
         TM    UNEXFLAG,X'01'     Was this a Unit Exception only?
         BNO   OTHERERR           No. Just go on.
HANDLEOV DS    0H            If Unit Exception, then ask for new volume
         PUT   SYSPRINT,LINE      Write message
         BAL   R9,SUMMREPT        Print summary report before doing EOV
         TM    READFLAG,X'01'     If Read Only, skip EOV macro.
         BO    OTHERERR
         MVC   OURRC,=F'4'        Indicate scratch volumes asked for
         CLC   MAXRC,OURRC        Is MAXRC higher?
         BH    SAMERC03           Yes. Keep it.
         MVC   MAXRC,OURRC        No.  Raise MAXRC to this one.
SAMERC03 DS    0H
         EOV   TAPOUT
OTHERERR DS    0H
* --- >  handle eov on output - above
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE,ERRMESS2
         HEX   OUTLINE+34,4,UNFBYMVD    Print Reg 2
         HEX   OUTLINE+44,2,HDRLENG     Pring Header Length
         TM    FLAGSYST,X'02'           SYSMOVED ddname present?
         BNO   WRITBUFE                 No, can't write data to it.
         PUT   SYSMOVED,OUTLINE
WRITBUFE DS    0H                       Stats for data moved
** ---------- >>    Record the number of bytes written
         ST    R2,SAVER2N           Save prev contents of Register 2
         ST    R3,SAVER3N           Save prev contents of Register 3
         XR    R2,R2                High order is zero
         L     R2,BLOKBYTS          Load Current Written Byte Count
         LA    R3,DBIN              Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,DBINF             Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
** -->   label byte counts and data byte counts  <-- **  below
         TM    ISLBLFLG,X'01'       This is a label file?
         BO    ADLABCNT             If so, go count its bytes
         LA    R3,DAIN              This is a data file--count bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,DAINF             This is a data file--count bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         B     NOLABCNT             Don't count twice
ADLABCNT DS    0H
         LA    R3,LBIN              Count the label file's bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,LBINF             Count the label file's bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
NOLABCNT DS    0H
** -->   label byte counts and data byte counts  <-- **  above
         L     R2,SAVER2N           Restore prev contents of Register 2
         L     R3,SAVER3N           Restore prev contents of Register 3
** ---------- >>    Record the number of bytes written
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE,MESSAGE3
         HEX   OUTLINE+34,4,UNFBYMVD    PRINT TOTAL BYTES MOVED
         HEX   OUTLINE+44,2,HDRLENG     PRINT HEADER LENGTH
         HEX   OUTLINE+52,2,BLOKBYTS+2  PRINT PREVIOUS LENGTH
         TM    FLAGSYST,X'02'           SYSMOVED ddname present?
         BNO   WRITBUFX                 No, can't write data to it.
         PUT   SYSMOVED,OUTLINE
         OI    BWRITFLG,X'01'           Show you've been here
WRITBUFX DS    0H
         L     R9,SAVER9WR          BAL register restore for WRITBUFF
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
WRITTPMK DS    0H               Routine to write a tape mark
         ST    R9,SAVER9WR      BAL register save for WRITTPMK
         TM    READFLAG,X'01'   Is this run READ ONLY ?
         BO    WRITTPME         Yes. Bypass entire routine.
         LA    R1,TAPOUT        R1=address of current DCB
         ST    R1,OUTDCBPT      Put it in IOB
         MVI   OUTCCW,X'1F'     Tape Mark opcode
         MVC   OUTCCWST(2),OUTCCW+6   Store previous move value
         MVC   OUTCCW+6(2),X'0000'    Shove zeros into length field
*                                     so AWSTAPE emulator doesn't barf
         MVI   OUTECB,X'00'     Initialize ECB
         EXCP  OUTIOB           Write the tape mark
         WAIT  ECB=OUTECB       Wait for write to complete
         CLI   OUTECB,X'7F'     Write completed normally?
         BNE   WRITTPER         No. Indicate tape mark write error.
         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE
         MVC   OUTCCW+6(2),OUTCCWST   Restore bytes moved field in CCW
         B     WRITTPME         Don't indicate error condition
WRITTPER DS    0H               Tape mark write error display
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE,ERRMESS4
         HEX   OUTLINE+34,4,OUTECB
         HEX   OUTLINE+44,8,OUTCSW
         PUT   SYSPRINT,OUTLINE
         MVI   OUTCCW,X'01'     Reset CCW opcode to WRITE
         MVC   OUTCCW+6(2),OUTCCWST    Restore byte moved field in CCW
WRITTPME DS    0H
         L     R9,SAVER9WR      BAL register restore for WRITTPMK
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ
*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED
* --------------------------------------------------------- *
ADDCOUNT DS    0H                  Add Byte Count subroutine
         ST    R9,SAVER9AD         BAL register save for ADDCOUNT
         ST    R4,SAVER4N          Save and Restore
         ST    R5,SAVER5N             Work Registers
         L     R4,0(,R3)           Load high order counter
         L     R5,4(,R3)           Load low order counter
         AR    R5,R2               Add to byte count
         BNO   ADDCNOOV            No overflow, then branch
         LA    R4,1(,R4)           Else, overflow to high word
         X     R5,=X'7FFFFFFF'     Get rid of sign bit
ADDCNOOV DS    0H
         ST    R4,0(,R3)           Put updated counter in storage
         ST    R5,4(,R3)           Put updated counter in storage
         L     R4,SAVER4N          Save and Restore
         L     R5,SAVER5N             Work Registers
ADDCOUNE DS    0H                  End of routine - Return
         L     R9,SAVER9AD         BAL register restore for ADDCOUNT
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
SUMMREPT DS    0H                        Write Summary Totals
         ST    R9,SAVER9SU               Save BAL register
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
* >---- --- --- --->
         TM    FLAGNEWV,X'01'
         BZ    NOCHGVSR
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+3(130),MESSAGE7
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
NOCHGVSR DS    0H
* >---- --- --- --->
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG01
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),UNFINRCD   NUMBER OF INPUT RECORDS READ
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG02
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),INHDRS     NUMBER OF HEADERS ENCOUNTERED
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG03
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),INTYPE1    BEGINNING OF RECORD HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG04
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),INTYPE2    MIDDLE OF RECORD HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG05
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),INTYPE3    END OF RECORD HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG06
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),INTYPE4    END OF TAPE HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG07
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),INTYPE5    END OF TAPE HEADERS
         PUT   SYSPRINT,OUTLINE
* >---->
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM01
         PUT   SYSFILES,CNTLINE
NOSUMM01 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG04
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM02
         PUT   SYSFILES,CNTLINE
NOSUMM02 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG05
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,LBINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM03
         PUT   SYSFILES,CNTLINE
NOSUMM03 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG06
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DAINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM04
         PUT   SYSFILES,CNTLINE
NOSUMM04 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG08
         MVC   FILEBYTE,BYTESPAT
         MVC   CNTLINE+54(11),BLOKPAT
         ED    CNTLINE+54(11),BLOCKTOT+2
         MVC   CNTLINE+65(6),=C'Blocks'
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM05
         PUT   SYSFILES,CNTLINE
* >---->
*** -------- >>>
         TM    UNEXFLAG,X'01'
         BZ    NOMIDDLE
         MVC   CNTLINE,CNTLINE-1
         PUT   SYSFILES,CNTLINE
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '
         PUT   SYSFILES,CNTLINE
         MVC   CNTLINE,CNTLINE-1
         PUT   SYSFILES,CNTLINE
NOMIDDLE DS    0H
*** -------- >>>
NOSUMM05 DS    0H
* >---->
*** -------- >>>
         TM    UNEXFLAG,X'01'
         BZ    NOMIDDPR
         MVC   CNTLINE,CNTLINE-1
         PUT   SYSPRINT,CNTLINE
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE+1(37),=C' - VOLUME SWITCH HAS OCCURRED HERE - '
         PUT   SYSPRINT,CNTLINE
         MVC   CNTLINE,CNTLINE-1
         PUT   SYSPRINT,CNTLINE
NOMIDDPR DS    0H
*** -------- >>>
SUMMREPE DS    0H                  END OF ROUTINE - RETURN
         L     R9,SAVER9SU         Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
LABELCHK DS    0H         Check for the presence of tape labels
*                         and set label flags, accordingly,
*                         in the LBLFLAG byte.
*
*              X'01'    HDR1 HAS BEEN SEEN
*              X'02'    HDR2 HAS BEEN SEEN
*              X'04'    VOL1 HAS BEEN SEEN
*              X'08'    HDR1 IS FROM AN INITTED TAPE
*              X'10'    EOF1 HAS BEEN SEEN
*              X'20'    EOF2 HAS BEEN SEEN
*              X'40'    EOV1 HAS BEEN SEEN
*              X'80'    EOV2 HAS BEEN SEEN
*
* --------------------------------------------------------- *
         ST    R9,SAVER9LC          Save BAL register
         NI    ISLBLFLG,FF-X'01'    Turn off "Is Label" flag at start
         LA    R1,TESTLABL          Point to 80 bytes to be tested.
         CLC   =C'VOL1',0(R1)       Is this a VOL1 ?
         BE    CVOL1                Process THE VOL1
         CLC   =C'HDR1',0(R1)       Is this a HDR1 ?
         BE    CHDR1                Process HDR1
         CLC   =C'HDR2',0(R1)       This a HDR2 ?
         BE    CHDR2                Process HDR2
         CLC   =C'EOF1',0(R1)       This an EOF1 ?
         BE    CEOF1                Process EOF1
         CLC   =C'EOF2',0(R1)       This an EOF2 ?
         BE    CEOF2                Process EOF2
         CLC   =C'EOV1',0(R1)       This an EOV1 ?
         BE    CEOV1                Process EOV1
         CLC   =C'EOV2',0(R1)       This an EOV2 ?
         BE    CEOV2                Process EOV2
         CLC   =C'UHL',0(R1)        This a User Header Label?
         BE    CUHL                 Process UHL
         CLC   =C'UTL',0(R1)        This a User Trailer Label?
         BE    CUTL                 Process UTL
         B     NOTLABEL             80 byte record is not an IBM SL
*        ------------------------------------------------------ *
CVOL1    DS    0H                   PROCESS VOL1 LABEL
         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
* ----- >    CHANGE OUTPUT VOLUME NAME - below
         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?
         BE    NOCHGVOL                  Yes. Don't change the volser.
         CLI   FLAGNEWV,X'01'            Is the flag on, to change vol?
         BNE   NOCHGVOL                  No. Don't change it.
         L     R1,SVINAREA               Point to INAREA
         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.
         MVC   MESSAGE7+28(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.
NOCHGVOL DS    0H
* ----- >    CHANGE OUTPUT VOLUME NAME - above
         B     LABCHEND
CHDR1    DS    0H
         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS
         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.
         L     R1,SVINAREA               Point to INAREA
         CLC   4(23,R1),ZERO23      WAS TAPE INITTED?
         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET
         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE
         OI    FLAGHDRL,X'01'
CHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CHDR2    DS    0H
         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2
         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         OI    FLAGHDRL,X'01'
         B     LABCHEND
CEOF1    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1
         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.
         B     LABCHEND
CEOF2    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2
         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.
         B     LABCHEND
CEOV1    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1
         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.
         B     LABCHEND
CEOV2    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2
         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         NI    FLAGHDRL,FF-X'01'  Initially not after HDR1 or HDR2.
         B     LABCHEND
*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *
CUHL     DS    0H                   HANDLE USER HEADER LABELS
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CUTL     DS    0H                   HANDLE USER TRAILER LABELS
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *
NOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF "IS LABEL" FLAG
         L     R9,SAVER9LC          Restore BAL register
LABCHEND BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
REPTFILE DS    0H       Routine to write block and byte counts
*                       for each file in the SYSFILES ddname.
* --------------------------------------------------------- *
         ST    R9,SAVER9RP
*----------->>
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG07
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   CNTLINE+54(11),BLOKPAT
         ED    CNTLINE+54(11),BLOCKCNT+2
         MVC   CNTLINE+65(6),=C'Blocks'
         MVC   CNTLINE+90(11),BLOKPAT
         ED    CNTLINE+90(11),BLOCKTOT+2
         MVC   CNTLINE+102(10),=C'Cum Blocks'
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE00
         PUT   SYSFILES,CNTLINE
NOFILE00 DS    0H
*--->                   Block counts first  -  above
         TM    FILBLFLG,X'01'            Is this a label file?
         BO    LBLSMSG0                  Yes. Show labels, not data.
         MVC   CNTLINE,CNTLINE-1         Clear line.
         MVC   CNTLINE(38),CTMSG01A      Tell it's labels written.
         B     ENDSMSG0
LBLSMSG0 DS    0H
         MVC   CNTLINE,CNTLINE-1         Clear line.
         MVC   CNTLINE(38),CTMSG01B      Tell it's data written.
ENDSMSG0 DS    0H
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3  Put file count in message
*--->
         TM    FILBLFLG,X'01'            Is this a label file?
         BO    DISLABLS                  Yes. Do the label treatment.
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DAINFH          Bytes moved counts for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINFL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
* >--->
         MVC   DATBYTES,BYTESPAT
         L     R4,DAINH           Cumulative data bytes written
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(43),DATDISPL
         L     R4,SAVER4Q
         B     DISPDATA
* >--->
DISLABLS DS    0H
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,LBINFH          Bytes moved counts for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINFL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
* >--->
         MVC   LABBYTES,BYTESPAT
         L     R4,LBINH           Label bytes written, cumulative
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(43),LABDISPL
         L     R4,SAVER4Q
         B     DISPDATA
* >--->
DISPDATA DS    0H
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE01
         PUT   SYSFILES,CNTLINE
NOFILE01 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG02
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBINFH          Bytes written for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBINFL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
* >--->
         MVC   CUMBYTES,BYTESPAT
         L     R4,DBINH           Bytes written, cumulative
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(43),CUMDISPL
* >--->
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE02
         PUT   SYSFILES,CNTLINE
NOFILE02 DS    0H
         L     R4,SAVER4Q
         MVC   CNTLINE,CNTLINE-1
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE03
         PUT   SYSFILES,CNTLINE
NOFILE03 DS    0H
REPTFEND DS    0H
         L     R9,SAVER9RP
         BR    R9
* --------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
VALIDHDR DS    0H                     VALIDATE HEADER GOTTEN
         NI    HDRVFLAG,FF-X'01'      Turn off invalid header flag.
         CLI   HEADER+4,X'A0'
         BE    VALIDHEN               Yes. Header is OK.
         CLI   HEADER+4,X'80'
         BE    VALIDHEN               Yes. Header is OK.
         CLI   HEADER+4,X'20'
         BE    VALIDHEN               Yes. Header is OK.
         CLI   HEADER+4,X'00'
         BE    VALIDHEN               Yes. Header is OK.
         CLI   HEADER+4,X'40'
         BE    VALIDHEN               Yes. Header is OK.
         OI    HDRVFLAG,X'01'         Flag found header as invalid.
VALIDHEN DS    0H
         BR    R9
* ----------------------------------------------------------------- *
*      CCWs and IOB for the EXCP operations.
* ----------------------------------------------------------------- *
OUTCCW   DC    X'01',AL3(0),X'2000',X'FFFF'     OUTPUT AREA OVERLAID
OUTECB   DC    F'0'
OUTIOB   DC    X'02000000'
         DC    A(OUTECB)
OUTCSW   DC    2F'0'
OUTCCWPT DC    A(OUTCCW)
OUTDCBPT DC    A(TAPOUT)
         DC    F'0'
         DC    X'00010000'
         DC    XL44'00'            PADDING
         SPACE 3
* ----------------------------------------------------------------- *
         ENTRY AWSIN
AWSIN    DCB   DDNAME=AWSIN,MACRF=GM,EODAD=FIN,DSORG=PS,LRECL=80
TAPOUT   DCB   MACRF=(E),DDNAME=TAPOUT,DEVD=TA,DSORG=PS,RECFM=U
         ENTRY SYSPRINT
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X
               EODAD=SYSINEND
         DC    CL8' '
FF       EQU   X'FF'
* ----------------------------------------------------------------- *
*
* AWSTAPE BLOCK HEADER
*
* ----------------------------------------------------------------- *
HEADER   DS    0CL6                     BLOCK HEADER
HDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH
HDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH
HDRFLAG1 DC    X'00'                    FLAGS BYTE 1...
HDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD
HDRF1MOR EQU   X'00'                    ...MIDDLE OF RECORD
HDRF1EOR EQU   X'20'                    ...END OF RECORD
HDRF1TMK EQU   X'40'                    ...TAPE MARK
HDRFLAG2 DC    X'00'                    FLAGS BYTE 2
* ----------------------------------------------------------------- *
*
INHEADER DC    XL6'00'
UNEXFLAG DC    X'00'                    FLAGS BYTE 1...
         DC    XL80'00'                 PADDING
HDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD
HDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD
HDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED
HDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD
HDRPRVF  DC    XL2'00'
HDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED
HDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD
HDRLENFL DC    XL2'00'
HDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER
HDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD
HDRPRVFL DC    XL2'00'
HDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER
OUTCCWST DC    XL2'00'             Byte count in CCW - saved during WTM
         DC    XL2'00'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         BR    R4                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEXSAVE  DS    3F                    Register save for HEX macro
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
         ORG   HEXSAVE       SAVE A LITTLE STORAGE              \
DB       DC    D'0'          DOUBLE-WORD WORK AREA              \
DB2      DC    0D'0',PL8'0'  DOUBLE-WORD WORK AREA              \
*  TABLE OF DAYS IN PRIOR MONTH                                 \
DATETABL DC   H'0,31,59,90,120,151,181,212,243,273,304,334,365' \
         EJECT
* -------------------------------------------- *
* ---------- *      F L A G S     * ---------- *
* -------------------------------------------- *
* ---------- *
BWRITFLG DC    X'00'    MESSAGE3 was already written flag.
*              X'01'    Don't have to write SYSMOVED message now.
* ---------- *
INITFLAG DC    X'00'    First invocation of UNFOLDEM at beg of tape.
*              X'01'    After the first invocation of UNFOLDEM.
* ---------- *
HDRVFLAG DC    X'00'    HEADER IS VALID IF X'00'
*              X'01'    HEADER IS INVALID--FILE MUST BE CORRUPTED
* ---------- *
LBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN
*              X'01'    HDR1 HAS BEEN SEEN
*              X'02'    HDR2 HAS BEEN SEEN
*              X'04'    VOL1 HAS BEEN SEEN
*              X'08'    HDR1 IS FROM AN INITTED TAPE
*              X'10'    EOF1 HAS BEEN SEEN
*              X'20'    EOF2 HAS BEEN SEEN
*              X'40'    EOV1 HAS BEEN SEEN
*              X'80'    EOV2 HAS BEEN SEEN
* ---------- *
READFLAG DC    X'00'               This run is "READ ONLY"  ?
*              X'01'         Yes, read only.
* ---------- *
ISLBLFLG DC    X'00'               80 BYTE BLOCK IS NOT A LABEL
*              X'01'         80 BYTE BLOCK IS A LABEL
* ---------- *
FILBLFLG DC    X'00'               IS THE FILE A LABEL FILE?
*              X'01'         THIS FILE IS A LABEL FILE
* ---------- *
FLAGHDRL DC    X'00'               HEADER LABEL FLAG
*              X'01'         EOT HEADER IS FOLLOWING A HEADER LABEL
* ---------- *
FLAGSYST DC    X'00'           FLAG TO SHOW IF SYSTRACE DD IS THERE
*              X'01'         //SYSTRACE DD IS THERE
*              X'02'         //SYSMOVED DD IS THERE
*              X'04'         //SYSFILES DD IS THERE
*              X'08'         //SYSIN    DD IS THERE
* ---------- *
FLAGNEWV DC    X'00'           FLAG TO SHOW IF A NEW VOLSER PLUGGED IN
*              X'01'         SVNEWVOL FIELD HAS BEEN SUBSTITUTED.
* ---------- *
NOWRTFLG DC    X'00'           FLAG TO SHOW NOT END OF BLOCK
*              X'01'           ON - HAVE TO CONTINUE IN SAME BUFFER
* ---------- *
UNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK
*                                   ------ ---- ------- -----
UNFSCARD DC    F'0'                 Start address of 80-byte card
UNFECARD DC    F'0'                 End address of 80-byte card
UNFOFFST DC    F'0'                 OFFSET of data to be moved
UNFBYTES DC    F'0'                 Number of bytes to be unfolded
UNFBYMVD DC    F'0'                 Number of bytes that were moved
UNFBUFFR DC    F'0'                 Current start address in buffer
UNFBSTRT DC    F'0'                 Original start address of buffer
UNFINRCD DC    PL7'0'               Number of GETs for AWSIN records
UNFLENTH EQU   *-UNFAREA
* -------------------------------------------- *
BLOKBYTS DC    F'0'                Count of bytes for block.
FILEBYTS DC    F'0'                Count of bytes for file.
* -------------------------------------------- *
SVNEWVOL DC    CL6' '              SAVED NEW VOLUME
CHKNWVOL DC    CL6' '              Raw saved volser before syntax check
DWORD    DC    D'0'
SAVR2T5  DC    4F'0'
QWORD    DS    PL16
TWO31    DC    P'2147483648'       2 TO THE 31ST
INHDRS   DC    PL7'0'
INTYPE1  DC    PL7'0'
INTYPE2  DC    PL7'0'
INTYPE3  DC    PL7'0'
INTYPE4  DC    PL7'0'
INTYPE5  DC    PL7'0'
FILCOUNT DC    PL7'0'
FERCOUNT DC    PL7'0'
BLOCKCNT DC    PL7'0'
BLERRCNT DC    PL7'0'
BLOCKTOT DC    PL7'0'
DECVALUE DS    CL8
FILEPAT  DC    X'402020202020202120'
BLOKPAT  DC    X'4020202020202020212020'
EDPAT    DC    X'40206B2020206B2020206B2020206B202120'
BYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'
FILEBYT  DS    0CL32
FILEBYTE DC    C' 9,999,999,999,999,999,999'
         DC    C' Bytes'
CUMDISPL DS    0CL43
CUMBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Total Bytes'
LABDISPL DS    0CL43
LABBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Label Bytes'
DATDISPL DS    0CL43
DATBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Data Bytes '
*
SAVEEN80 DS    F         Addresses:  80 bytes past record end
SAVEENDC DS    F                     Record end location
SAVEBEGC DS    F                     Record beginning location
BEGDATA  DS    F                     Where this record's data begins
*
* below - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *
* ------                      Move count for bytes in the buffer
BYTEBFWD DS    0F
BYTEFILL DC    H'0'
BYTEMOVE DC    H'0'
* ------
SVUNFOLD DC    F'0'           Entry point of UNFOLDEM subprogram
SVINAREA DS    F
SAVER2E  DS    F
SAVER4E  DS    F
SAVER5E  DS    F
SAVER2N  DS    F              Has to do with byte counting subroutine
SAVER3N  DS    F              Has to do with byte counting subroutine
SAVER4B  DS    F              HEX print register save
SAVER4N  DS    F              Has to do with byte counting subroutine
SAVER4Q  DS    F              Has to do with byte counting subroutine
SAVER5N  DS    F              Has to do with byte counting subroutine
* --- below                   SAVE BAL REGISTER for each subroutine
SAVER9HV DS    F              Has to do with Header Validation
SAVER9AD DS    F              Has to do with ADDCOUNT routine
SAVER9AF DS    F              Has to do with AFTRMOVE routine
SAVER9WR DS    F              Has to do with WRITBUFF routine
SAVER9WT DS    F              Has to do with WRITTPMK routine
SAVER9CH DS    F              Has to do with CHKHEADR routine
SAVER9LC DS    F              Has to do with LABELCHK routine
SAVER9RP DS    F              Has to do with REPTFILE routine
SAVER9SU DS    F              Has to do with SUMMREPT routine
* --- above                   SAVE BAL REGISTER for each subroutine
*
* above - - - - - - - - - - - - -  Various Save Areas - - - - - - - - *
OURRC    DC    F'0'
MAXRC    DC    F'0'
HDRBYTES DS    F
HDRBSAVE DS    F
SAVER8C2 DS    F
         DC    C' '
ZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1
*
*  -----------------            Error Message Texts
ERRMESS1 DC    CL133'    BUFFER OVERFLOW ERROR  '
ERRMESS2 DC    CL133'    TAPE OUTPUT WRITE ERROR'
ERRMESS3 DC    CL133'    OFFSET ERROR           '
ERRMESS4 DC    CL133'    TAPE MARK WRITE ERROR  '
ERRMESS5 DC    CL133' >> AWS HEADER IS INVALID - CORRUPTION AT THIS POI-
               NT >> '
ERRMESS6 DC    CL133' >> AWS HEADER IS INVALID - PREV BYTES - CURR BYTE-
               S  >> '
*
*  -----------------            Tape Output Error Message Texts
OUTEQC   DC    C' ********** EQUIPMENT CHECK ON DD XXXXXX, UNIT '
         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '
         DC    40C'*'
OUTUNEX  DC    C' *********** TAPE HAS ENDED ON DD XXXXXX, UNIT '
         DC    C' XXX, VOLUME XXXXXX -- PRIVATE SCRATCH REQUESTED '
         DC    37C'*'
OUTDCK   DC    C' **********      DATA CHECK ON DD XXXXXX, UNIT '
         DC    C' XXX, VOLUME XXXXXX -- THIS OUTPUT TERMINATED '
         DC    40C'*'
*
*  -----------------            Header Message Texts
MESSAGE1 DC    CL133'1VTT2TAPE - AWS TAPE FILE TO ACTUAL TAPE CONVERSIO-
               N PROGRAM  '
MESSAGE4 DC    CL133'1VTT2TAPE  -  AWS TAPE HEADER TRACE REPORT  '
MESSAGE5 DC    CL133'1VTT2TAPE - AWS TAPE DATA MOVE - TRACE AND ERROR R-
               EPORT  '
MESSAGE6 DC    CL133'1VTT2TAPE - AWS TAPE FILE REPORT - MOVE AND WRITE -
               STATS  '
MESSAGE8 DS    0CL133
         DC    CL8' '
         DC    CL12'HEADER TEXT '
         DC    CL1' '
         DC    CL4'TYPE'
         DC    CL3' '
         DC    CL10'UNFSCARD'
         DC    CL10'UNFECARD'
         DC    CL10'UNFOFFST'
         DC    CL10'UNFBYTES'
         DC    CL10'UNFBYMVD'
         DC    CL10'UNFBUFFR'
         DC    CL10'UNFBSTRT'
         DC    CL14'UNFINRCD'
         DC    CL21' '
MESSAGE9 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -
               IS GOTTEN BY THE PROGRAM, IN READING THROUGH A TAPE.'
MESSAG10 DC    CL133'        THE UNFAREA (UNFOLD AREA CONTROL BLOCK) FI-
               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST GOTTEN.-
               '
*  -----------------            Diagnostic Info Message Texts
MESSAGE2 DC    CL133'  OFFSET SIZE AND LOCATION '
MESSAGE3 DC    CL133'  NUMBER OF BYTES WRITTEN  '
MESSAGE7 DC    CL133'  VOLSER OVERRIDDEN TO:    '
MESSAG11 DC    CL133'  NUMBER OF CHUNK BYTES    '
MESSAG12 DC    CL133'  -- End of File Marker - File Number'
*
*  -----------------            Summary Totals Message Texts
PRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS IN:  '
PRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS IN:  '
PRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS   :  '
PRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS   :  '
PRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS   :  '
PRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS :  '
PRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK :  '
*
*  -----------------            Byte Count Message Texts
CTMSG01A DC    CL38'     DATA   WRITTEN FOR FILE:         '
CTMSG01B DC    CL38'     LABELS WRITTEN FOR FILE:         '
CTMSG02  DC    CL38'     BYTES  WRITTEN FOR FILE:         '
CTMSG03  DC    CL38'     TOTAL BYTES   MOVED  FOR TAPE  : '
CTMSG04  DC    CL38'     TOTAL BYTES  WRITTEN FOR TAPE  : '
CTMSG05  DC    CL38'     TOTAL BYTES  WRITTEN FOR LABELS: '
CTMSG06  DC    CL38'     TOTAL BYTES  WRITTEN FOR DATA  : '
CTMSG07  DC    CL38'     BLOCKS WRITTEN FOR FILE:         '
CTMSG08  DC    CL38'     TOTAL BLOCKS WRITTEN FOR TAPE  : '
*
*    ------------------------ >   Output Line Buffers  -  below
         DC    C' '
LINE     DC    CL133' '
         DC    C' '
CNTLINE  DC    CL133' '
         DC    C' '
OUTLINE  DC    CL133' '
         DC    C' '
PRTLINE  DC    CL133' '
*    ------------------------ >   Output Line Buffers  -  above
         LTORG
* --- >
SAVEHDR  DS    0CL6
SAVCURLN DS    XL2
SAVPRVLN DS    XL2
SAVHFLGS DS    X
SAVHREST DS    X
* --- >
PREVHDR  DS    0CL6
PRVCURLN DS    XL2
PRVPRVLN DS    XL2
PRVHFLGS DS    X
PRVHREST DS    X
* --- >
EOTMARK  DC    XL6'000000004000'
DBINF    DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE
DBINFH   DC    F'0'
DBINFL   DC    F'0'
DBIN     DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL
DBINH    DC    F'0'
DBINL    DC    F'0'
LBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES
LBINH    DC    F'0'
LBINL    DC    F'0'
LBINF    DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES
LBINFH   DC    F'0'
LBINFL   DC    F'0'
DAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES
DAINH    DC    F'0'
DAINL    DC    F'0'
DAINF    DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES
DAINFH   DC    F'0'
DAINFL   DC    F'0'
         DC    CL8' '
*    ------------------------ >   Constants for Date and Time - below
SAVE1402 DS    6F                 Extra fullword for safety
TIMED    DS    CL7
DATED    DS    CL9
DATETIME DS    4F
         ORG   DATETIME
TIME     DS    CL4
         DS    CL4
DATE     DS    CL5
         DS    CL3
HEADDLIT DS    0CL31              Literal for headings - date and time
         DC    CL6'Today:'
         DC    CL2' '
HEADDATE DC    CL23' '
LEVELLIT DS    0CL21              Level number display for headings
         DC    CL6'Level '
LEVELL   DC    CL4'&LLEV'
         DC    CL2' ('
LEVDATE  DC    CL8' '             Assembly date for this program
         DC    CL1')'
*    ------------------------ >   Constants for Date and Time - above
*      Uppercase alpha and only allow printable characters.
TRTBLPRT DS    0D
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'404040404040404040404A4B4C4D4E4F'
         DC    XL16'504040404040404040405A5B5C5D5E5F'
         DC    XL16'606140404040404040406A6B6C6D6E6F'
         DC    XL16'404040404040404040407A7B7C7D7E7F'
         DC    XL16'40C1C2C3C4C5C6C7C8C9404040404040'
         DC    XL16'40D1D2D3D4D5D6D7D8D9404040404040'
         DC    XL16'4040E2E3E4E5E6E7E8E9404040404040'
         DC    XL16'40404040404040404040404040404040'
         DC    XL16'C0C1C2C3C4C5C6C7C8C9404040404040'
         DC    XL16'D0D1D2D3D4D5D6D7D8D9404040404040'
         DC    XL16'E040E2E3E4E5E6E7E8E9404040404040'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9404040404040'
*
TESTLABL DC    CL80' '
GETSYSIN DC    CL80' '
INCARDP  DC    XL80'00'           Previous card-image read
INCARD   DC    XL80'00'           Current  card-image read
INCAEND  EQU   *
         DC    XL80'00'           Room for another card-image
         DS    0F
         DC    CL8' '
INAREA   DS    CL65535            Buffer to hold tape blocks
         DS    CL800              Padding, so as not to overrun
*                                 somebody else's storage by mistake.
         IEZIOB DSECT=YES
         SPACE
         YREGS
         END
./       ADD   NAME=UNFOLDEM
   TITLE 'UNFOLDEM -- UNFOLD FB-80 DATA INTO A LONG BUFFER'
*                           -------------------------------------
*                           It is probably not necessary to run
*                           this program in 24-bit mode.  But
*                           it works when it is run that way.
*                           -------------------------------------
*                           We do want old MVS systems to be able
*                           to run this routine.
*                           -------------------------------------
*
*  ---------------------------------------------------------------  *
*                                                                   *
*  SUBROUTINE:    UNFOLDEM                                          *
*                                                                   *
*  DESCRIPTION:                                                     *
*                                                                   *
*      This program is the heart of the process of creating a       *
*      real tape from an AWS-format tape file, which has been       *
*      folded over into an FB-80 dataset.  The AWS header           *
*      contains the number of bytes in the next chunk (complete     *
*      or partial block) of tape data.  Once this quantity is       *
*      known, and the beginning position of the data has been       *
*      established (it starts just after the header ends), then     *
*      the data itself has to be moved into a buffer, in            *
*      preparation for that data block being written out to a       *
*      tape.  This program unfolds the correct amount of data,      *
*      beginning at a known position in the FB-80 file, into        *
*      the buffer.  The position in the FB-80 file which marks      *
*      the beginning of the data to be moved, is called the         *
*      OFFSET into the 80-byte card, and it starts with position    *
*      +0.                                                          *
*                                                                   *
*  INPUTS and OUTPUTS:   Described below.                           *
*                                                                   *
*  FILES NEEDED:                                                    *
*                                                                   *
*      This program assumes that the caller has opened DCBs for     *
*      an FB-80 file called AWSIN, which contains its input         *
*      "virtual tape" data, and for SYSPRINT.  This program         *
*      needs to do GETs from AWSIN, and if necessary, it needs      *
*      to write messages to SYSPRINT.  The caller has to provide    *
*      ENTRY AWSIN and ENTRY SYSPRINT statements in front of        *
*      the AWSIN and SYSPRINT DCBs, respectively.                   *
*                                                                   *
*  METHOD OF OPERATION:                                             *
*                                                                   *
*      This program operates using a control block, called the      *
*      UNFAREA, which is passed from the caller and back to the     *
*      caller.  Both the caller and this program update the         *
*      UNFAREA.  Upon entry to this program, R1 is expected to      *
*      point to the UNFAREA.                                        *
*                                                                   *
*      The caller does one GET of the FB-80 file, to read an        *
*      AWS header (that has tape data following it).  Once the      *
*      AWS header has been read, there should be enough data to     *
*      supply to the UNFAREA control block, and then this           *
*      program is called, to complete the move of that tape data    *
*      to a buffer, and position the FB-80 input just past the      *
*      data moved, so it should point to the next AWS header.       *
*                                                                   *
*      This program does more GETs from the FB-80 input file,       *
*      until the request for the number of bytes to be moved,       *
*      is satisfied.                                                *
*                                                                   *
*      The following is the layout of the UNFAREA.  Fields          *
*      marked with an arrow must be supplied upon input to this     *
*      program.                                                     *
*                                                                   *
*      UNFAREA  DS    0F          UNFOLD AREA CONTROL BLOCK         *
*      *                          ------ ---- ------- -----         *
*  --> UNFSCARD DC    F'0'        Start address of 80-byte card     *
*  --> UNFECARD DC    F'0'        End address of 80-byte card       *
*  --> UNFOFFST DC    F'0'        OFFSET of data to be moved        *
*  --> UNFBYTES DC    F'0'        Number of bytes to be unfolded    *
*      UNFBYMVD DC    F'0'        Number of bytes that were moved   *
*  --> UNFBUFFR DC    F'0'        Current start address in buffer   *
*  --> UNFBSTRT DC    F'0'        Original start address of buffer  *
*      UNFINRCD DC    PL7'0'      Number of GETs for AWSIN records  *
*      UNFLENTH EQU   *-UNFAREA                                     *
*      *                                                            *
*                                                                   *
*      The rest of the fields are calculated by this program        *
*      and returned to the caller.                                  *
*                                                                   *
*      UNFBUFFR and UNFOFFST are updated by this program, and       *
*      upon return to the caller, they point to the output data     *
*      and input data positions, respectively, that are just        *
*      after the moved data, so as to wait for the next call,       *
*      to be able to move more data.  UNFBSTRT preserves the        *
*      very beginning address of the output buffer, whereas         *
*      UNFBUFFR is a place somewhere within the buffer, which       *
*      is the start of where the new data is expected to be         *
*      moved.                                                       *
*                                                                   *
*      Since both the caller and this program do GET operations     *
*      from the input FB-80 file, the count of the number of GETs   *
*      done, UNFINRCD, is updated by BOTH the caller and by this    *
*      program.                                                     *
*                                                                   *
*  ---------------------------------------------------------------  *
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
*  ---------------------------------------------------------------  *
*    This macro is used to display hex values in a printed report.
*  ---------------------------------------------------------------  *
&NAME    DS    0H
         ST    R4,SAVER04
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAVER04
         LM    15,1,HEXSAVE
         MEND
         SPACE
UNFOLDEM CSECT ,                                                \
UNFOLDEM AMODE 24
UNFOLDEM RMODE 24
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'UNFOLDEM '
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME '
SAVEAREA DC    18F'0'
EYECATCH DS    0D                    ENSURE ALIGNMENT
         STM   R14,R12,12(R13)
         LR    R5,R1                 SAVE PARM POINTER
         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR
         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1                NEW SAVE AREA ADDRESS
         DROP  R15
* -----                              SET UP BASE REGISTERS
         USING UNFOLDEM,R12,R11
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LR    R1,R5                 RESTORE PARM POINTER
         ST    R1,SAVEPARM
         L     R0,SYSPRINV           SYSPRINT DCB address in caller
         ST    R0,SYSPRDCB             store for the program's use
         L     R0,AWSINV             AWSIN    DCB address in caller
         ST    R0,AWSINDCB             store for the program's use
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*                                                                   *
*   Routine to unfold FB-80 data starting at an OFFSET from the     *
*   beginning of a card, for a certain number of bytes, to a data   *
*   buffer area whose beginning address is supplied.  More 80-byte  *
*   records can be read with the GET macro from the FB-80 file, to  *
*   fulfill the move request.                                       *
*                                                                   *
*   Input:   UNFAREA fields are all supplied by the calling         *
*            program, except for UNFBYMVD which is calculated       *
*            by this program and returned to the caller.  The       *
*            UNFAREA is pointed to by Register 1.                   *
*                                                                   *
*            The initial card image which is supplied by the        *
*            calling program, already is primed with data to be     *
*            moved (one card's worth of it).  This card contains    *
*            the starting point for the data to be moved, at an     *
*            OFFSET (displacement) from the beginning of the card.  *
*                                                                   *
*            The input data also contains the address of an         *
*            output buffer area, which is the target for the        *
*            (segmented) data moves.  Data will be strung out       *
*            into this area, one card (or a partial card) at a      *
*            time.  The current card which is in the input file,    *
*            which contains the beginning of the data to be         *
*            moved, has already been loaded into a card image       *
*            work area pointed to by the calling program.  The      *
*            OFFSET into this card is where the data to be moved    *
*            will start.                                            *
*                                                                   *
*            It is the responsibility of the calling program to     *
*            ensure that this routine has access to all of the      *
*            buffer storage where the data is supposed to be        *
*            moved to.                                              *
*                                                                   *
*   Output:  Data is moved, for the required number of bytes, to    *
*            the output buffer area.  When more that one card       *
*            image's worth of data has to be moved, more cards      *
*            are obtained with the GET macro, from the input file.  *
*                                                                   *
*            Ending OFFSET in the FB-80 input file, pointing to     *
*            just after the data which was moved, in the final      *
*            card image gotten, is returned to the UNFOFFST field   *
*            and reported to the caller, in anticipation of the     *
*            next call to this routine.                             *
*                                                                   *
*            Ending address of data in buffer - one byte after      *
*            the end of the moved data - is returned in the         *
*            UNFBUFFR field.  The UNFBSTRT field preserves the      *
*            address of the beginning of the data buffer.           *
*                                                                   *
*            A count of bytes actually moved from the FB-80 file    *
*            to the output buffer area is reported in the UNFBYMVD  *
*            field.  This must match the byte count of bytes which  *
*            needed to be moved initially.  That count had been     *
*            initially supplied by the calling program in the       *
*            UNFBYTES field.                                        *
*                                                                   *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
UNFOLD   DS    0H
         ST    R1,PARMPTR
         L     R2,=A(UNFBLOCK)
         USING UNFBLOCK,R2
         MVC   UNFAREA(UNFLENTH),0(R1)      Move input block to pgm
         LA    R2,UNFAREA                   And address it.
         MVC   SAVEBEGC,UNFSCARD    Save "start of card" address
         MVC   SAVEENDC,UNFECARD    Save "end of card" address
         L     R1,UNFSCARD          Address of card
         MVC   WORKPREV(80),ZEROCARD   Zero prev work area
         MVC   WORKCURR(80),0(R1)   Move card image to curr work area
         MVC   UNFBYMVD,=F'0'       Initialize count of bytes moved
         L     R7,UNFSCARD          Point to beginning of card
         A     R7,UNFOFFST          Add OFFSET to start of input
         ST    R7,SAVEBEGI          Save where input starts
         L     R8,SAVEBEGI          Copy beg of input address
         A     R8,UNFBYTES          Make hypothetical end address,
*                                   by adding the bytes to be moved.
* - - - - - - - - - - - - - - >>    This may be way past the address
*             of the end of the FB-80 card.  We will decrease this
*             address as we move bytes from successive cards to the
*             data buffer, by 80 bytes at a time, as we GET new cards,
*             until R8 actually falls within the end-of-card address.
*             We will then use this address to calculate the new
*             OFFSET for the next piece of data in the FB-80 file.
*             The new OFFSET is returned to the caller by modifying
*             the UNFOFFST field in the control block.
*
* <--------- SET UP LOOP TO START MOVING THE DATA ------->
LOOPSET  DS    0H                   Start moving data
         L     R3,UNFBUFFR          Point to beginning of buffer
         ST    R3,SAVEBEGD          Save location in the program.
         LR    R4,R3                Point R4 to end of data by adding
         A     R4,UNFBYTES          the number of bytes to the start.
         ST    R4,SAVEENDD          Save potential end of data location
         ST    R8,SAVER8TR          Save R8 for trace.
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*  Cases:  1.  Current move is within the current card.           *
*              Covered by LOOPSHRT routine.                       *
*                                                                 *
*          2.  Current move is past the current card.             *
*              Covered by LOOPMORE routine.                       *
*                                                                 *
*        R6 always contains the number of bytes to be moved       *
*        for this segment.                                        *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
LOOPINIT DS    0H
         C     R8,SAVEENDC          Is R8 still past end-of-card?
         BH    LOOPMORE             Yes. Copy till end and GET.
LOOPSHRT DS    0H                   The move is short, not past end.
         LR    R6,R8                No. Get byte count to move NOW.
         SR    R6,R7                Bytes to move
         C     R6,=F'80'            More than 80?
         BH    LOOPERR1             Yes. Has to be error, so flag it.
         BCTR  R6,0                 No. One less for EXECUTE.
         EX    R6,MOVEBUFF          Move the data to the buffer.
         LA    R6,1(,R6)            Restore count of bytes moved
         L     R1,UNFBYMVD          Increment
         AR    R1,R6                  total
         ST    R1,UNFBYMVD          Store it away for later.
         LA    R3,0(R6,R3)          Bop past beginning buffer address.
*        MVC   LINE+1(8),=C'LSHRT1: '
*        BAL   R9,UNFIMAGE
         CR    R3,R4                Not equal to predicted end?
         BNE   LOOPERR2             Error, so flag it.
         ST    R3,UNFBUFFR          Return modified new buffer address.
         LR    R6,R8                Calculate new OFFSET - save R8
         S     R6,UNFSCARD          Subtract beginning of card address
         ST    R6,UNFOFFST          Store the result as new OFFSET
*        MVC   LINE+1(8),=C'LSHRT2: '
*        BAL   R9,UNFIMAGE
         B     RETURN
*
LOOPMORE DS    0H                   Data move if more than one card
*
         L     R6,SAVEENDC          We're going past end-of-card
         SR    R6,R7                Subtract beg address of data
         C     R6,=F'80'            Still bigger than 80?
         BH    LOOPERR1             Yes. Has to be error.
         BCTR  R6,0                 Subtract one for EXECUTE
         EX    R6,MOVEBUFF          Move data into buffer
         LA    R6,1(,R6)            Restore byte count
         L     R1,UNFBYMVD          Increment
         AR    R1,R6                  total
         ST    R1,UNFBYMVD              bytes moved
         LA    R3,0(R6,R3)          Bop past data moved in buffer
*        MVC   LINE+1(8),=C'LMORE1: '
*        BAL   R9,UNFIMAGE
         CR    R3,R4                Test if past end
         BH    LOOPERR3             Yes. Has to be an error.
         ST    R3,UNFBUFFR          Re-point current buffer address.
         S     R8,=F'80'            -80 bytes because new card gotten
         MVC   WORKPREV,WORKCURR    Save card image to previous
         ST    R10,SAVER10          Save register for safety
         L     R10,AWSINDCB         Point to AWSIN DCB in caller
         GET   (10),WORKCURR        Get a new card image
         L     R10,SAVER10          Restore R10
         AP    UNFINRCD,=P'1'       Increment count of AWSIN rcrds read
         L     R7,SAVEBEGC          Point to beginning addr of workarea
         MVC   0(80,R7),WORKCURR    Overlay caller's card image
*        MVC   LINE+1(8),=C'LMORE2: '
*        BAL   R9,UNFIMAGE
         C     R8,SAVEENDC          Is R8 within the card image end?
         BH    LOOPMORE             No. Do the LOOPMORE routine.
         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.
         SPACE 3
* ----------------------------------------------------------------- *
MOVEBUFF MVC   0(*-*,R3),0(R7)      << EXECUTED >>
* --------------------------------------------------------- *
LOOPERR1 DS    0H                   Error entry location
         MVC   LINE,LINE-1
         MVC   LINE+1(9),=C'LOOPERR1 '
         BAL   R9,UNFIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
LOOPERR2 DS    0H                   Error entry location
         MVC   LINE,LINE-1
         MVC   LINE+1(9),=C'LOOPERR2 '
         BAL   R9,UNFIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
LOOPERR3 DS    0H                   Error entry location
         MVC   LINE,LINE-1
         MVC   LINE+1(9),=C'LOOPERR3 '
         BAL   R9,UNFIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
* --------------------------------------------------------- *
RETURN   DS    0H                   RETURN TO THE OPERATING SYSTEM
         ST    R10,SAVER10          Save register for safety
         L     R10,SAVEPARM         Address of UNFAREA in caller
         MVC   0(UNFLENTH,R10),UNFAREA    Copy changed UNFAREA back
         L     R10,SAVER10          Restore R10
         L     R13,4(,R13)
         MVC   16(4,R13),=F'0'      Load Maximum Return Code
         MVC   24(4,R13),=A(UNFBLOCK)  Return address of UNFAREA in R1.
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
* --------------------------------------------------------- *
* --------------------------------------------------------- *
* ---      S U B R O U T I N E S                        --- *
* --------------------------------------------------------- *
UNFIMAGE DS    0H          Diagnostic Data - State of UNFAREA currently
*
         HEX   LINE+10,4,UNFSCARD
         HEX   LINE+20,4,UNFECARD
         HEX   LINE+30,4,UNFOFFST
         HEX   LINE+40,4,UNFBYTES
         HEX   LINE+50,4,UNFBYMVD
         HEX   LINE+60,4,UNFBUFFR
         HEX   LINE+70,4,UNFBSTRT
         HEX   LINE+80,4,SAVER8TR
         HEX   LINE+90,7,UNFINRCD
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
         BR    R9
* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *
UNFBLOCK CSECT
UNFAREA  DS    0F                   UNFOLD AREA CONTROL BLOCK
*                                   ------ ---- ------- -----
UNFSCARD DC    F'0'                 Start address of 80-byte card
UNFECARD DC    F'0'                 End address of 80-byte card
UNFOFFST DC    F'0'                 OFFSET of data to be moved
UNFBYTES DC    F'0'                 Number of bytes to be unfolded
UNFBYMVD DC    F'0'                 Number of bytes that were moved
UNFBUFFR DC    F'0'                 Current start address in buffer
UNFBSTRT DC    F'0'                 Original start address of buffer
UNFINRCD DC    PL7'0'               Number of GETs for AWSIN records
UNFLENTH EQU   *-UNFAREA
*
UNFOLDEM CSECT
WORKPREV DS    CL80                 Contiguous previous card image
WORKCURR DS    CL80                 Card image work area
         DC    C' '
LINE     DC    CL133' '
         DC    C' '
LINE2    DC    CL133' '
*
FF       EQU   X'FF'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         BR    R4                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEXSAVE  DS    3F                    Register save for HEX macro
SAVER04  DS    H                     Register save for HEX macro
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ZEROCARD DC    80X'00'
SAVEBEGD DC    F'0'                 Save beg of buffer data address
SAVEENDD DC    F'0'                 Save end of buffer data address
SAVEBEGI DC    F'0'                 Save beg address of card input
SAVEBEGC DC    F'0'                 Save beg address of card
SAVEENDC DC    F'0'                 Save end address of card
SAVER8TR DC    F'0'                 Save floating Reg 8 which decreases
SAVEPARM DC    F'0'                 Save CALLER'S UNFAREA ADDRESS
PARMPTR  DC    F'0'
SYSPRINV DC    V(SYSPRINT)
AWSINV   DC    V(AWSIN)
SYSPRDCB DC    F'0'
AWSINDCB DC    F'0'
SAVER10  DC    F'0'
         SPACE
         YREGS
         END
./       ADD   NAME=VTT2DISK
   TITLE 'VTT2DISK -- READ A REAL TAPE AND CREATE FB-80 AWS FILE'
**************************************************************
**************************************************************
**                                                          **
**                                                          **
**  MODULE:  VTT2DISK.   Written by Sam Golob               **
**                                                          **
**       Copyright (c) 2001-2005 by Sam Golob               **
**                                                          **
**       A component of the:                                **
**       Virtual Tape Transportation System (VTTS)          **
**                                                          **
**  PURPOSE:  Program to read in a tape, and create an      **
**            MVS disk file in "folded FB-80 AWS format".   **
**                                                          **
**     The output of this program is intended to be input   **
**     for the VTT2TAPE program.  These two programs,       **
**     VTT2DISK and VTT2TAPE, are designed to work          **
**     together, as paired and opposite programs.           **
**                                                          **
**  OBSERVATION:  Although this program is purely an MVS    **
**                program, the AWS-format output of this    **
**     program can be downloaded to other systems where     **
**     the file can actually be interpreted as an emulated  **
**     tape.  This is one way of transferring tape data to  **
**     other MVS systems that can read AWS-format tape      **
**     files directly, as though they were tapes.           **
**                                                          **
**     For example, you can take mainframe-based tapes      **
**     on real cartridges and create AWS-format tape        **
**     files that can be read on a FLEX-ES system, a P/390  **
**     or a Hercules-based MVS system.                      **
**                                                          **
**     Arbitrary chunk sizes for the AWS-format tape files  **
**     are now supported.  If you are reading the output    **
**     file on a Hercules-based system, you should          **
**     rename its file name as *.het , because the HET      **
**     emulator on Hercules recognizes chunked blocks.      **
**                                                          **
**  METHOD:                                                 **
**                                                          **
**     Tape data is read into a data buffer in this         **
**     program.  Each block is read in, and its size        **
**     is determined.  This size is compared to the         **
**     chunk size, and a decision is made as to what        **
**     to do.  An AWS header is made for each chunk.        **
**     Each AWS header is folded into FB-80 output,         **
**     and then the data is folded in afterward, until      **
**     the block, and its associated AWS headers, are       **
**     all folded in.  Then another tape block is read      **
**     into the buffer, and the process repeats.            **
**                                                          **
**     When the tape file ends, and a tape mark is read     **
**     in, an X'40' format AWS header is constructed.       **
**     It is then folded into the FB-80 output dataset,     **
**     after the last data.                                 **
**                                                          **
**     At the end of the tape, an end-of-tape AWS           **
**     header is appended to the end of the output          **
**     file and folded in.  The last FB-80 record           **
**     is completed with hex zeros, if necessary.           **
**                                                          **
**     As a controversial measure, a full 80-byte record    **
**     of hexzeros is appended at the end of the file.      **
**                                                          **
**     All of the "FB-80 folding" work is now done by the   **
**     sub-program called FOLDEM.  The FOLDEM program       **
**     operation is completely controlled by a control      **
**     block called the FLDAREA control block, which does   **
**     all of the communication between the main program    **
**     and the FOLDEM sub-program.  Therefore, monitoring   **
**     of the folding process is now possible purely by     **
**     displaying the current status of the FLDAREA         **
**     fields.  A convenient routine for displaying the     **
**     status of the FLDAREA fields is the FLDIMAGE         **
**     routine in either program, which is invoked by:      **
**                                                          **
**     BAL   R9,FLDIMAGE                                    **
**                                                          **
**     Therefore the fold monitoring displays that used     **
**     to be in the SYSMOVED DD name, are now obsolete.     **
**                                                          **
**     There are two more fields in the FLDAREA control     **
**     block than in the UNFAREA control block of the       **
**     UNFOLDEM sub-program that VTT2TAPE uses.  These      **
**     are:                                                 **
**                                                          **
**           FLDBYTOT - bytes left in buffer after the      **
**                      last chunk of data was folded       **
**           FLDREADF - propagation of the "read only"      **
**                      flag into the sub-program           **
**                                                          **
**     These extra fields are obviously not required by     **
**     the unfolding process.  The first one is not         **
**     required because you're doing "unchunking" instead   **
**     of "chunking", and you read the existing chunks      **
**     as they come in; you're not required to create       **
**     them.  The second one is not required because the    **
**     main program writes the output (a tape) instead of   **
**     the sub-program writing the output (an FB-80 file).  **
**     So in our case, if no output is to be written, the   **
**     sub-program must know about it.                      **
**                                                          **
**  OPTIONAL DDNAMES:                                       **
**                                                          **
**     In order to make sure that the VTT2DISK program      **
**     is doing its job properly, it produces a lot of      **
**     trace data and status data, as it is creating        **
**     the folded FB-80 AWS format tape.  In order not      **
**     to clutter the summary report, most of this          **
**     data is written to "Optional DDNAMEs".  Starting     **
**     with version 1.12 of this program, most of the       **
**     trace data now consists of the state of the FLDAREA  **
**     control block fields at various stages of program    **
**     execution.                                           **
**                                                          **
**     If you have access to the source code (you are       **
**     reading it), you can introduce an instruction:       **
**                                                          **
**           BAL   R9,FLDIMAGE                              **
**                                                          **
**     at any point in the program, as long as SYSPRINT     **
**     is open.  This should produce any diagnostics you    **
**     may need, because all FLDAREA fields are displayed.  **
**                                                          **
**     Optional DDNAMEs don't have to be coded in the       **
**     JCL.  But if they are coded, they will contain       **
**     the extra trace data which VTT2DISK produces,        **
**     and the SYSFILES ddname will contain a detailed      **
**     "file by file" report.                               **
**                                                          **
**     The SYSFILES report is very useful if you want       **
**     to do a "dry run", with the READ parameter.  If      **
**     you want to know the structure of a tape without     **
**     creating the FB-80 output file, the SYSFILES         **
**     report will tell you what files are on the tape.     **
**     It will also give you an indication of how big an    **
**     FB-80 output file you will need on an MVS disk,      **
**     to contain all the tape data.  See below for         **
**     details.                                             **
**                                                          **
**     The optional DDNAMEs are SYSTRACE, SYSFILES,         **
**     and SYSIN.  SYSMOVED is now obsolete, although       **
**     it will produce a dummy report if it is present      **
**     in the JCL.                                          **
**                                                          **
**     SYSIN data is necessary if optional parameters       **
**     are to be entered, such as:                          **
**                                                          **
**     CHUNKSIZE=nnnn                                       **
**     NEWVOL=volser                                        **
**     READ                                                 **
**     IDRCOFF                                              **
**                                                          **
**     SYSIN keywords have to start in column 1.            **
**                                                          **
**     Either READ or IDRCOFF can also be entered in the    **
**     PARM field of the EXEC card in the JCL.              **
**                                                          **
**     Full JCL to run the VTT2DISK program is as           **
**     follows:                                             **
**                                                          **
**     //   jobcard                                         **
**     //AWSREAD  EXEC PGM=VTT2DISK                         **
**     //STEPLIB   DD  DISP=SHR,DSN=your.load.library       **
**     //*AWSOUT   DD  DSN=fb80.folded.aws.file,DISP=SHR    **
**     //*        .... if the file is preallocated ....     **
**     //AWSOUT    DD  DSN=fb80.folded.aws.file,            **
**     //          DISP=(NEW,CATLG,DELETE),UNIT=SYSALLDA,   **
**     //          VOL=SER=volxxx,                          **
**     //          SPACE=(CYL,(mm,nn),RLSE)                 **
**     //          DCB=(RECFM=FB,LRECL=80,BLKSIZE=nnnnn)    **
**     //TAPIN     DD  DISP=OLD,UNIT=562,VOL=SER=TEST01,    **
**     //          LABEL=(1,BLP,EXPDT=98000)                **
**     //SYSPRINT  DD  SYSOUT=*                             **
**     //SYSFILES  DD  SYSOUT=*                             **
**     //SYSTRACE  DD  SYSOUT=*                             **
**     //SYSUDUMP  DD  SYSOUT=*                             **
**     //SYSIN     DD  *                                    **
**     keywords in column 1                                 **
**     /*                                                   **
**                                                          **
**     where you can leave out SYSTRACE and SYSUDUMP        **
**     if you want to.  I'd strongly suggest including      **
**     (at least) SYSFILES, though.                         **
**                                                          **
**     SYSTRACE takes a picture of the tape buffer at       **
**     READ time, and takes a picture of the AWS headers    **
**     and the FLDAREA control block fields at the time     **
**     the headers are made.  Since the folding is now      **
**     done by the FOLDEM subprogram, SYSMOVED, which       **
**     used to track the data folding process, is now       **
**     not necessary.  Of course SYSUDUMP is there to       **
**     contain the MVS-produced dump, upon any abnormal     **
**     termination of the program.                          **
**                                                          **
**     SYSFILES gives you block counts and byte counts      **
**     for all files read and written.                      **
**                                                          **
**     In the SYSPRINT report, there is a count of total    **
**     number of 80-byte records which the program will     **
**     (or has) put out.  If you are doing a READ only      **
**     run, and want to allocate an output file which is    **
**     the right size, you might use this number, together  **
**     with the BLKnnnn command from File 296 of the CBT    **
**     Tape, to produce the following result:               **
**                                                          **
**     Say, our program produces:                           **
**                                                          **
**     TOTAL NUMBER OF RECORDS OUT:            4,152,837    **
**                                                          **
**     And you want to allocate space on a 3390.  So you    **
**     would say:                                           **
**                                                          **
**     BLK3390 80 BLKSIZE(27920) RECORDS(4152837)           **
**                                                          **
**     Which comes up with the result:                      **
**                                                          **
** FOR BLKSIZE 27,920  AND 4,152,837 RECORDS, ALLOCATE:     **
**    11,900 BLOCKS,     5,950 TRACKS, OR   397 CYLINDERS   **
**                                                          **
**  CHANGE LOG:                                             **
**                                                          **
**    Version 1.1 - Make sure program works properly        **
**       folding the data from the input buffer into FB-80. **
**                                                          **
**    Version 1.2 - Level number in the report headings.    **
**                                                          **
**    Version 1.3 - Not stopped by null SL tape file.       **
**                                                          **
**    Version 1.4 - Byte count and cum byte count report    **
**       in SYSFILES.  Differentiate between label bytes    **
**       and data bytes in the reports.                     **
**                                                          **
**    Version 1.5 - Block counts for each file and for the  **
**       entire tape.                                       **
**                                                          **
**    Version 1.6 - Fix a reporting problem with block      **
**       counting.                                          **
**                                                          **
**    Version 1.7 - Allow PARM=READ, just to get stats.     **
**                                                          **
**    Version 1.8 - Make file-level stats reporting into    **
**       a subroutine.  Fix a bug in cumulative data byte   **
**       reporting.                                         **
**                                                          **
**    Version 1.9 - End program if error on input tape.     **
**       If input tape is AWS with bad headers, break the   **
**       loop upon thinking you have an infinite number of  **
**       tape marks on input.                               **
**                                                          **
**    Version 1.9A - Accommodate 4 character version level. **
**       Add extra line of ASCII blanks (X'20') to the      **
**       output, to make Hercules happy, and to detect      **
**       end-of-tape more easily.                           **
**                                                          **
**    Version 1.10 - PARM of IDRCOFF will turn off IDRC     **
**       indicators in the VOL1, HDR2, EOF2, EOV2 labels.   **
**                                                          **
**    Version 1.11 - Last line has hexzeros instead of      **
**       hex 20 as fillers.  It makes Hercules happier.     **
**                                                          **
**    Version 1.12 - Re-architected program to use FOLDEM   **
**       sub-program for data moves.  The FOLDEM program    **
**       is driven by the FLDAREA control block, so the     **
**       trace data consists mostly of the state of the     **
**       FLDAREA control block fields.  A routine called    **
**       FLDIMAGE will print all the FLDAREA control block  **
**       fields on a single SYSPRINT line.                  **
**                                                          **
**       Added the possibility of coding program options    **
**       in the SYSIN DD, which is used if it is present    **
**       in the JCL.  SYSIN keywords, which must be coded   **
**       to start in column 1, are currently:               **
**                                                          **
**       CHUNKSIZE=nnnn                                     **
**       NEWVOL=volser                                      **
**       READ                                               **
**       IDRCOFF                                            **
**                                                          **
**       Added CHUNKSIZE=nnnn SYSIN keyword to allow the    **
**       creation of "chunked AWS tape files by this        **
**       program.  The AWS tape file architecture allows    **
**       for unlimited tape block sizes, if the blocks      **
**       are broken into "chunks" of 65535 bytes or less,   **
**       separated by AWS headers.  IBM's original AWS      **
**       tape standard used to require a maximum chunk      **
**       size of only 4096 bytes.  In this program, 65535   **
**       bytes is the default chunk size, but this value    **
**       can be adjusted at assembly time by setting a      **
**       global variable.                                   **
**                                                          **
**       The NEWVOL=volser keyword in SYSIN, allows you     **
**       to change the volser in the VOL1 label of the      **
**       output AWS-format tape file.                       **
**                                                          **
**       Now, the READ and IDRCOFF keywords of the EXEC     **
**       PARM field, can also be coded in SYSIN.  They      **
**       must begin in column 1.  READ allows a dry run     **
**       of the program which reads the input tape and      **
**       reports statistics, but which does not produce     **
**       an output FB-80 AWS file.                          **
**                                                          **
**       IDRCOFF looks in the tape standard labels, if      **
**       there are any, and turns off any "P" indicators    **
**       which tell MVS that this tape was produced on      **
**       an IDRC-enabled tape drive.  Since the output      **
**       FB-80 file is not compressed anyway, one wants     **
**       the power to read the AWS-format tape file on a    **
**       logical 3420 or 3480 tape drive, without MVS       **
**       telling you that "the tape has compressed files    **
**       and I can't read it" on this particular drive.     **
**                                                          **
**                                                          **
**************************************************************
         EJECT
**************************************************************
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
.* ---------------------------------------------------------------  *
.*   This macro is used to display hex values in a printed report.  *
.* ---------------------------------------------------------------  *
&NAME    DS    0H
         ST    R4,SAVER4B
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAVER4B
         LM    15,1,HEXSAVE
         MEND
         SPACE
**************************************************************
         GBLC  &LLEV
         GBLC  &DEFCHKC
         GBLA  &DEFCHNK
&LLEV    SETC  '1.12'
* ------------------------------------------------------------------ *
*   DEFAULT CHUNKSIZE FOR THE OUTPUT FB-80 AWS FILE PRODUCED BY      *
*   THIS PROGRAM, IS SET HERE.  AS DISTRIBUTED, THE VALUE IS 65535.  *
* ------------------------------------------------------------------ *
&DEFCHNK SETA  65535
&DEFCHKC SETC  '&DEFCHNK'
         YREGS
         EJECT
** -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- **
VTT2DISK CSECT
*                           It is probably not necessary to run
*                           this program in 24-bit mode.  But
*                           it works when it is run that way.
VTT2DISK AMODE 24
VTT2DISK RMODE 24
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'VTT2DISK - REAL TAPE TO FOLDED FB-80 AWS DISK FILE - '
         DC    C'LEVEL '
SYSLEV   DC    C'&LLEV'
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME ',C'--- '
         DC    C'Copyright (c) 2001-2005 by Sam Golob '
SAVEAREA DC    18F'0'
EYECATCH DS    0D                    ENSURE ALIGNMENT
         SAVE  (14,12)
         LR    R5,R1                 SAVE PARM POINTER
         LA    R1,SAVEAREA           NEW SAVE-AREA ADDR
         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1                NEW SAVE AREA ADDRESS
         DROP  R15
* -----                              SET UP BASE REGISTERS
         USING VTT2DISK,R12,R11,R10,R8,R7
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LA    R10,4095(,R11)
         LA    R10,1(,R10)
         LA    R8,4095(,R10)
         LA    R8,1(,R8)
         LA    R7,4095(,R8)
         LA    R7,1(,R7)
         LR    R1,R5                 RESTORE PARM POINTER
*
* ----- >                            Parms          <--- below
         L     R1,0(R1)              Get PARM field
         CLC   =C'READ',2(R1)        Is it "READ" only?
         BE    COPYREAD              Yes. Turn on indicator.
         CLC   =C'IDRCOFF',2(R1)     Do we turn off IDRC indicators?
         BE    COPYIDRF              Yes. Say that.
         B     COPYTAPE              No. Just go on with processing.
COPYREAD DS    0H                    READ only?
         OI    READFLAG,X'01'        Yes. Turn on flag indicating so.
         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.
         B     COPYTAPE
COPYIDRF DS    0H                    IDRC indicators off?
         OI    IDRCFLAG,X'01'        Yes. Turn on flag.
         B     COPYTAPE
*  Note:  READ and IDRCOFF can also be set in SYSIN in column 1.
COPYTAPE DS    0H
* ----- >                            Parms          <--- above
*
***********************************************************************
* GET SYSTEM DATE AND TIME - A standard way to get date and time      *
***********************************************************************
         STM   R14,R2,SAVE1402
*NEW*    TIME  DEC,DATETIME,LINKAGE=SYSTEM,DATETYPE=MMDDYYYY
         TIME  DEC           OLD AND SLOW                       \
         STCM  R0,15,TIME
         OI    TIME+3,X'0F'
*NEW*    STCM  R1,15,DATE+1                                     \
*NEW*    OI    DATE+4,X'0F'
*NEW*    UNPK  DATED,DATE
*  INSERTION TO SUPPORT DATE IN MVS 3.8                         \
         ST    R1,DB+4       SAVE JULIAN DATE                   \
         CLI   DB+4,1        DID USER SUPPLY A CENTURY?         \
         BH    HAVECENT      YES                                \
         AP    DB+4(4),=P'1900000'  ELSE ADD IT IN              \
HAVECENT MVO   DB2,DB+4(2)   ISOLATE THE YEAR                   \
         XC    DB(6),DB      ISOLATE THE DAYS                   \
         CVB   R1,DB         CONVERT DAYS TO BINARY             \
         CVB   R2,DB2        CONVERT YEAR TO BINARY             \
         SLR   R0,R0         SET FOR NO LEAP DAY ADJUSTMENT     \
*  N.B.: THIS WORKS UNTIL 2099 ONLY                             \
         EX    R2,EXISLEAP   TEST FOR MULTIPLE OF FOUR          \
         BNZ   NOTALEAP      BRANCH IF NOT A LEAP YEAR          \
         CH    R1,=H'60'     ON, BEFORE, OR AFTER LEAP DAY?     \
         BL    NOTALEAP      BEFORE; TREAT NORMALLY             \
         BH    ONELESS       AFTER; ADJUST DAY                  \
         LA    R0,1          SET LEAP DAY ADJUSTMENT            \
ONELESS  BCTR  R1,0          ONE LESS TO FIX DAYS AFTER LEAP DAY\
NOTALEAP LA    R4,DATETABL   GET TABLE OF CUMULATIVE DAYS       \
         LR    R5,R4         SAVE                               \
FINDMON  CH    R1,2(,R4)     IN THIS MONTH?                     \
         BNH   FOUNDMON      YES; PROCESS                       \
         LA    R4,2(,R4)     INCREMENT                          \
         B     FINDMON       AND TRY AGAIN                      \
FOUNDMON SH    R1,0(,R4)     SUBTRACT DAYS IN PRIOR MONTHS      \
         AR    R1,R0         ADJUST 1 IF LEAP DAY               \
         LA    R4,2(,R4)     FINAGLE TO MAKE MONTH COME OUT RIGHT
         SR    R4,R5         GET OFFSET TO MONTH                \
         SRL   R4,1          GET MONTH (1-12)                   \
*  WE NOW HAVE FULL YEAR IN R2, MONTH IN R4, AND DAY IN R1      \
         MH    R4,=H'100'    SHIFT FOR EDIT                     \
         AR    R4,R1         ADD DAY: MMDD                      \
         MH    R4,=H'10000'  SHIFT FOR EDIT                     \
         AR    R4,R2         NOW HAVE MMDDYYYY                  \
         MH    R4,=H'10'     FINAGLE A LITTLE MORE              \
         CVD   R4,DB         MAKE PACKED AND SIGNED             \
         UNPK  DATED,DB      CONFORM TO *NEW* CODE              \
EXISLEAP TM    =X'03',*-*    MULTIPLE OF FOUR?                  \
         SPACE 1                                                \
         UNPK  TIMED,TIME
*                          FILL HEADDATE AREA WITH INFO TO REUSE
         MVC   HEADDATE(2),DATED
         MVI   HEADDATE+2,C'/'
         MVC   HEADDATE+3(2),DATED+2
         MVI   HEADDATE+5,C'/'
         MVC   HEADDATE+6(4),DATED+4
         MVC   HEADDATE+12(2),TIMED
         MVI   HEADDATE+14,C':'
         MVC   HEADDATE+15(2),TIMED+2
         MVI   HEADDATE+17,C':'
         MVC   HEADDATE+18(2),TIMED+4
         MVC   MESSAGE1+88(31),HEADDLIT    Today's date and time
         MVC   MESSAGE2+88(31),HEADDLIT      in the reports.
         MVC   MESSAGE3+88(31),HEADDLIT
         MVC   MESSAGE4+88(31),HEADDLIT
         LM    R14,R2,SAVE1402
***********************************************************************
         MVC   LEVDATE(8),SYSDAT
***********************************************************************
         MVC   MESSAGE1+61(21),LEVELLIT    Program level and
         MVC   MESSAGE2+61(21),LEVELLIT      assembly date
         MVC   MESSAGE3+61(21),LEVELLIT
         MVC   MESSAGE4+61(21),LEVELLIT
***********************************************************************
* ----------------------------------------------------------------- *
INITEM   DS    0H                    Initialize some constants
         MVC   FOLDHIGH(2),=X'0000'  High order of fullwords.
         MVC   FULLHIGH(2),=X'0000'
         MVC   CURRBYTE(2),=X'0000'
         MVC   LASTBYTE(2),=X'0000'
         MVC   HDRSIZE(4),=F'6'      Set size of header globally.
         MVC   FLDOFFST(4),=F'0'     Offset is initially zero
         LA    R1,OUTCARD            Let FOLDEM know about AWSOUT area
         ST    R1,FLDSCARD           Beginning of card image output
         ST    R1,SVBEGCRD
         LA    R1,80(,R1)            Find end of card
         ST    R1,FLDECARD           And store it away for the duration
         ST    R1,SVENDCRD
         L     R1,=A(INAREA)         Get address of input buffer
         ST    R1,SVBFAREA           And save it away.
         ST    R1,FLDBUFFR           Prime these fields
         ST    R1,FLDBSTRT
         L     R0,=F'&DEFCHNK'       Set default chunk size.
         ST    R0,CHNKSIZE           Default is X'FFFF' unless changed.
         ZAP   FLDOUTCT,=P'0'        Zero count of AWSOUT records.
* ----------------------------------------------------------------- *
TIOTSCAN DS    0H             Determine the presence of Optional
*                             DDNAMEs:  SYSTRACE, SYSMOVED, SYSFILES
* ----->                      and open them if there is JCL for them.
* ----------------------------------------------------------------- *
         L     R5,16          R5=CVT
         L     R5,0(,R5)      R5=TCB WORDS
         L     R5,4(,R5)      R5=MY TCB
         L     R5,12(,R5)     R5=TIOT
         LA    R5,24(,R5)     R5=FIRST DD ENTRY
TIOTLOOP CLC   0(4,R5),=XL4'00' END OF TIOT?
         BE    TIOTSEND       YES, CHECK FOR OUTPUT VOL OVERRIDES
         CLC   4(8,R5),SYSTRACE+40  SYSTRACE ddname there?
         BNE   TIOTMOVD       NO
*DEBUG*  OI    FLAGSYST,X'01'       Flag presence of SYSTRACE DD
         B     TIOTNEXT       CONTINUE
TIOTMOVD CLC   4(8,R5),SYSMOVED+40  SYSMOVED ddname there?
         BNE   TIOTFILE
         OI    FLAGSYST,X'02'       Flag presence of SYSMOVED DD
         B     TIOTNEXT
TIOTFILE CLC   4(8,R5),SYSFILES+40  SYSFILES ddname there?
         BNE   TIOTSYSN
         OI    FLAGSYST,X'04'       Flag presence of SYSFILES DD
         B     TIOTNEXT
TIOTSYSN CLC   4(8,R5),SYSIN+40     SYSIN ddname there?
         BNE   TIOTNEXT
         OI    FLAGSYST,X'08'       Flag presence of SYSIN DD
         B     TIOTNEXT
TIOTNEXT SR    R3,R3
         IC    R3,0(,R5)      R3=LENGTH OF DD ENTRY
         AR    R5,R3          R5=NEXT DD ENTRY
         B     TIOTLOOP       GO CHECK IT
TIOTSEND DS    0H
* ----------------------------------------------------------------- *
* ---    DO SYSIN PROCESSING IF THE DD IS THERE                 --- *
* ----------------------------------------------------------------- *
*
         BAL   R9,SCNSYSIN           Scan SYSIN for all its info.
*
* ----------------------------------------------------------------- *
***********************************************************************
*    Now OPEN the files and start the processing.
***********************************************************************
* - - - ->  Chunk Size Message - - - ->   below
*    The purpose of this code is to fill MESSAG14 with information.
         L     R1,CHNKSIZE                  Load binary Chunk Size
         XC    DWORD,DWORD                  Clear DWORD to zeros.
         CVD   R1,DWORD                     Convert to decimal.
         OI    DWORD+7,X'0F'                Make sign readable.
         MVC   MESSAG14+28(8),CHPATTRN      Load pattern into message
         ED    MESSAG14+28(8),DWORD+4       Edit the number
         B     AFCHKDSP                     Branch past constant
CHPATTRN DC    X'4020202020202120'          8 bytes of pattern
AFCHKDSP DS    0H
* - - - ->  Chunk Size Message - - - ->   above
         TM    READFLAG,X'01'        Read Only run?
         BO    NOAWSOUT              Yes. Don't OPEN AWSOUT.
         OPEN  (AWSOUT,(OUTPUT))
NOAWSOUT DS    0H
         OPEN  (SYSPRINT,(OUTPUT))
         OPEN  (TAPIN,(INPUT))
*--->>
         MVC   MSGLINE1,MSGLINE1-1   Clear optional
         MVC   MSGLINE2,MSGLINE2-1      message lines
READIDRC DS    0H
         TM    READFLAG,X'01'        READ only run?
         BZ    IDRCMSG
READMSG  DS    0H
         MVC   MSGLINE1+4(21),=C'This Run is READ ONLY'
IDRCMSG  DS    0H
         TM    IDRCFLAG,X'01'        Remove IDRC indicator from labels?
         BZ    ENDEXMSG
         MVC   MSGLINE2+4(24),=C'Turn IDRC indicators off'
ENDEXMSG DS    0H
*--->>
TRACERPT DS    0H
         TM    FLAGSYST,X'01'        DO WE WANT THE TRACE REPORT?
         BNO   MOVEDRPT              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSTRACE,(OUTPUT))
         PUT   SYSTRACE,MESSAGE2     Title message for SYSTRACE report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE      Blank Line
         PUT   SYSTRACE,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    TRACENOI
         PUT   SYSTRACE,MSGLINE2     IDRC remove message
TRACENOI DS    0H
         PUT   SYSTRACE,MESSAG14
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
TRACDESC DS    0H
         PUT   SYSTRACE,MESSAGE8
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAGE5
         PUT   SYSTRACE,MESSAGE6
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAG11
         PUT   SYSTRACE,MESSAG12
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSTRACE,OUTLINE
         PUT   SYSTRACE,MESSAGE7
*--->>
MOVEDRPT DS    0H
         TM    FLAGSYST,X'02'        DO WE WANT THE MOVED REPORT?
         BNO   FILESRPT              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSMOVED,(OUTPUT))
         PUT   SYSMOVED,MESSAGE3     Title message for SYSMOVED report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE      Blank Line
         PUT   SYSMOVED,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    MOVEDNOI
         PUT   SYSMOVED,MSGLINE2     IDRC remove message
MOVEDNOI DS    0H
         PUT   SYSMOVED,MESSAG14
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
         PUT   SYSMOVED,MESSAGE9
         PUT   SYSMOVED,MESSAG10
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
         PUT   SYSMOVED,MESSAG11
         PUT   SYSMOVED,MESSAG12
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSMOVED,OUTLINE
*--->>
FILESRPT DS    0H
         TM    FLAGSYST,X'04'        DO WE WANT THE FILES REPORT?
         BNO   NOSYSFIL              NO. THEN DON'T OPEN THE DCB.
         OPEN  (SYSFILES,(OUTPUT))
         PUT   SYSFILES,MESSAGE4     Title message for SYSFILES report
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSFILES,OUTLINE      Blank Line
         PUT   SYSFILES,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    FILESNOI
         PUT   SYSFILES,MSGLINE2     IDRC remove message
FILESNOI DS    0H
         PUT   SYSFILES,MESSAG14
*--->>
NOSYSFIL DS    0H
* ----------------------------------------------------------------- *
*   Now do the same for SYSPRINT report, which is always there.
* ----------------------------------------------------------------- *
         PUT   SYSPRINT,MESSAGE1
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         PUT   SYSPRINT,OUTLINE      Blank Line
         PUT   SYSPRINT,MSGLINE1     Read Only message or blank
         TM    IDRCFLAG,X'01'
         BZ    PRINTNOI
         PUT   SYSPRINT,MSGLINE2     IDRC remove message
PRINTNOI DS    0H
         PUT   SYSPRINT,MESSAG14
*--->>
*  TEST TEST TEST TEST TEST TEST TEST TEST TEST  Move as needed.
*        BAL   R9,FLDIMAGE
*--->>
* ----------------------------------------------------------------- *
TAPEREAD DS    0H                      READ a new tape block.
* ----------------------------------------------------------------- *
*   You come here every time you do a tape READ.
* ----------------------------------------------------------------- *
         NI    TPMKFLAG,X'FF'-X'02'    You haven't read two tape marks
         BAL   R9,READBLOK             Read a block of data
         TM    TPMKFLAG,X'01'          Was this read a Tape Mark?
         BO    MAINTPMK                Yes. Take appropriate action.
* --- >
         L     R1,CURRBFUL             Fullword number of bytes read
         C     R1,CHNKSIZE             Bigger than chunk size?
         BNH   NOCHUNKS                No. Don't chunk. X'A0' headers.
         OI    CHNKFLAG,X'01'          Yes. Headers to be chunked.
         NI    BUFINISH,FF-X'01'       Turn "buffer finished" flag off
         MVC   FLDBYTOT,CURRBFUL       Total bytes in buffer
         MVC   FLDBYTES,CHNKSIZE       Chunk size is bytes to be moved
         B     AFTRCHNK                Jump over other alternative
NOCHUNKS DS    0H
         NI    CHNKFLAG,FF-X'01'       Say it ain't so, Joe.
         OI    BUFINISH,X'01'          Buffer is finished in one shot.
         MVC   FLDBYTOT,CURRBFUL       Bytes in buffer is true total
         MVC   FLDBYTES,CURRBFUL       Bytes in buffer is current total
* --- >                                Label check if HDR - below
AFTRCHNK DS    0H
         CLC   CURRBYTE,=X'0050'       Exactly 80 bytes read?
         BNE   MAINNOTL                No. Can't be a label.
         BAL   R9,LABELCHK             Check for labels and their kind.
         TM    ISLBLFLG,X'01'          Is this record a label?
         BZ    MAINNOTL                No. Bypass flag setting.
         TM    LBLFLAG,X'03'           Is this label a HDR1 or HDR2?
         BZ    MAINNOTH                Neither. Check if EOF or EOV.
         OI    FLAGHDRL,X'01'          Flag just after a HDR 1 or 2.
MAINNOTH DS    0H
         TM    LBLFLAG,X'F0'           Is label an EOF or EOV?
         BZ    MAINNOTL                No. Don't turn off flag.
         NI    FLAGHDRL,FF-X'01'       After EOF or EOV. Turn flag off.
MAINNOTL DS    0H
* ----------------> BYTE COUNTS AT THE READ LEVEL  -  BELOW
** -->              stuff below is only done per READ.
         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3
         L     R2,CURRBFUL          Load Current READ Byte Count
         LA    R3,DBOUTF            Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,DBOUT             Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
** -->   label byte counts and data byte counts  <-- **  below
         TM    ISLBLFLG,X'01'       This is a label file?
         BO    ADLABCNT             If so, go count its bytes
         LA    R3,DAIN              This is a data file--count bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         B     NOLABCNT             Don't count twice
ADLABCNT DS    0H
         LA    R3,LBIN              Count the label file's bytes
         BAL   R9,ADDCOUNT          Increment Doubleword Count
NOLABCNT DS    0H
         LM    R2,R3,SAVEMOVE       Save prev contents of R2 and R3
** -->              stuff above is only done per READ.
* ----------------> BYTE COUNTS AT THE READ LEVEL  -  ABOVE
* --- >                                Label check if HDR - above
**-------------------------------------------------------------------**
FOLDSTRT DS    0H                   MAKE HEADERS AND FOLD DATA UNTIL
*                                   THE BUFFER IS EXHAUSTED.
         MVC   FLDSCARD,SVBEGCRD       Prime the FLDAREA card fields
         MVC   FLDECARD,SVENDCRD
         L     R3,=A(INAREA)           Point to the data buffer
         ST    R3,FLDBUFFR             Initialize
         ST    R3,FLDBSTRT                 FLDAREA fields
         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA
*                                      because we'll have to fold the
*                                      newly manufactured header.
**-------------------------------------------------------------------**
FOLDLOOP DS    0H
         L     R1,FLDBYTOT          Compare bytes remaining to fold
         C     R1,CHNKSIZE          To the chunk size.
         BH    FOLDNCHK             If now less than or equal
         NI    CHNKFLAG,FF-X'01'    Turn the chunk flag off
         OI    BUFINISH,X'01'       And turn "buffer finished" flag on
         MVC   FLDBYTES,FLDBYTOT    Only move bytes that are left.
FOLDNCHK DS    0H
         MVC   SAVAREA(SAVLENTH),FLDAREA   Save copy of entire FLDAREA
         BAL   R9,MAKEHEDR             Create a header with READ info
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER               Point to address of this header
         ST    R3,FLDBUFFR             Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF             And fold it into FB-80.
         MVC   SAVOFFST(4),FLDOFFST    Offset has to be current.
         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore entire FLDAREA
         MVC   FLDBYMVD,=F'0'          Initialize bytes folded
         BAL   R9,FOLDBUFF             And fold it into the output.
         NI    NWBLKFLG,FF-X'01'    Only first chunk is from new block
** ---------- >>    Record the number of bytes folded - below
         STM   R2,R3,SAVEMOVE       Save prev contents of R2 and R3
         L     R2,FLDBYMVD          Load Current folded Byte Count
         LA    R3,DBOUTFM           Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
         LA    R3,DBOUTM            Point Register to Counter
         BAL   R9,ADDCOUNT          Increment Doubleword Count
NOFLDCNT DS    0H
         LM    R2,R3,SAVEMOVE       Save prev contents of Register 2
** ---------- >>    Record the number of bytes folded - above
         TM    CHNKFLAG,X'01'          Are we doing chunks?
         BZ    TAPEREAD                No. Do another tape read.
         TM    BUFINISH,X'01'          Have we finished this block?
         BO    TAPEREAD                Yes. Read another block.
         B     FOLDLOOP                No. Fold more chunks.
*
MAINTPMK DS    0H                   Last read was a T.M.
         AP    TPMKCNT,=P'1'        Add 1 to Tape Mark count
         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk
         BAL   R9,MAKEHEDR          Make a header to show EOF.
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER            Load address of header
         ST    R3,FLDBUFFR          Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF          Fold the header into the output
         MVC   SAVOFFST,FLDOFFST    Offset has to be current
         MVC   SAVOUTCT,FLDOUTCT       Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore after folding header
         BAL   R9,REPTFILE          Report Block and Byte Counts
*--->>
         MVC   DBOUTF(8),=D'0'      Zero File Byte Count
         MVC   DBOUTFM(8),=D'0'     Zero File Byte Count
         ZAP   BLOCKCNT,=P'0'       Zero File Block Count
*--->>
         B     TAPEREAD             Read in another tape block.
*
* ---------------------------------------------------------------- *
*          END OF INPUT AWS DATA                                   *
* ---------------------------------------------------------------- *
FIN      DS    0H                   PROGRAM EXIT ROUTINE
         MVC   SAVAREA(SAVLENTH),FLDAREA   Preserve FLDAREA control blk
         OI    TPMKFLAG,X'01'       Force Tape Mark indication.
         BAL   R9,MAKEHEDR          Make EOT header
         MVC   FLDBYTES(4),HDRSIZE     Load length of header for fold
         MVC   FLDBYTOT(4),HDRSIZE     Load length of header for fold
         LA    R3,HEADER            Load address of header
         ST    R3,FLDBUFFR          Store it into FLDAREA fields
         ST    R3,FLDBSTRT
         BAL   R9,FOLDBUFF          Fold the header into the output
BREAKLUP DS    0H
         MVC   SAVOFFST,FLDOFFST    Offset has to be current
         MVC   SAVOUTCT,FLDOUTCT    Card count should be current too
         MVC   FLDAREA(FLDLENTH),SAVAREA   Restore FLDAREA control blk
         TM    READFLAG,X'01'       READ only?
         BO    NOPUT01              Yes. No output to AWSOUT.
         PUT   AWSOUT,OUTCARD       And write out the last buffer.
         MVC   OUTCARD(80),LASTLINE Add an extra card of hex zeroes
         PUT   AWSOUT,OUTCARD       And put it out too.
NOPUT01  DS    0H
         AP    FLDOUTCT,=P'1'       Count the record PUT out.
         AP    FLDOUTCT,=P'1'       Count the extra record of blanks
WRITSUMM DS    0H
         BAL   R9,SUMMREPT          Print the summary report.
* ---------------------------------------------------------------- *
*     Close the files that were OPENed
* ---------------------------------------------------------------- *
CLOSEMAL DS    0H                   Close em all.....
         CLOSE TAPIN
         TM    READFLAG,X'01'       Is this a READ only run?
         BO    NOAWSCLS             Can't CLOSE what ain't OPEN.
         CLOSE AWSOUT
NOAWSCLS DS    0H
         CLOSE SYSPRINT
         TM    FLAGSYST,X'01'       DID WE OPEN THE SYSTRACE DDNAME?
         BNO   SYSTRNOP             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSTRACE
SYSTRNOP DS    0H
         TM    FLAGSYST,X'02'       DID WE OPEN THE SYSMOVED DDNAME?
         BNO   SYSFILNO             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSMOVED
SYSFILNO DS    0H
         TM    FLAGSYST,X'04'       DID WE OPEN THE SYSMOVED DDNAME?
         BNO   SYSMVDNO             CLOSE ONLY IF WE OPENED IT.
         CLOSE SYSFILES
SYSMVDNO DS    0H
FIN1     DS    0H                   RETURN TO THE OPERATING SYSTEM
         L     R13,4(,R13)
         RETURN (14,12),RC=0
         EJECT
* ----------------------------------------------------------------- *
* ---       SUBROUTINES                                         --- *
* ----------------------------------------------------------------- *
*
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
SCNSYSIN DS    0H                 Routine to extract info from SYSIN.
         ST    R9,SAVER9SC
* -------------- >>>>>>   Look for SYSIN cards            - BELOW
         TM    FLAGSYST,X'08'       Is SYSIN there?
         BZ    SCNSYSIE             No. Then can't open it. So get out.
         OPEN  (SYSIN,(INPUT))
SYSINLUP DS    0H
         GET   SYSIN,GETSYSIN
         CLC   =C'NEWVOL=',GETSYSIN  Is the literal NEWVOL= in col 1?
         BE    SYSNWVOL              Yes. Go process the new volume.
         CLC   =C'CHUNKSIZE=',GETSYSIN     Changing the chunk size?
         BE    SYSCHUNK                    Looks that way.....
         CLC   =C'READ ',GETSYSIN
         BE    SYSREAD
         CLC   =C'IDRCOFF ',GETSYSIN
         BE    SYSIDRCO
         B     SYSINLUP              Look for another card.
SYSNWVOL DS    0H
         CLI   GETSYSIN+7,C' '       Is the next letter a blank?
         BE    SYSINLUP              Yes. Ignore this card.
         MVC   SVNEWVOL(6),GETSYSIN+7     Save the next 6 chars.
         B     SYSINLUP
SYSCHUNK DS    0H
         CLI   GETSYSIN+10,C' '  Is the first number value blank?
         BE    SYSINLUP          Yes. Ignore entire card.
         CLI   GETSYSIN+10,X'F0' Smaller than zero?
         BL    SYSINLUP          Yes. Get another card.
         CLI   GETSYSIN+10,X'F9' Bigger than X'F9' (number 9)?
         BH    SYSINLUP          Yes. Get another card.
         OI    FLAGCHNK,X'01'    Show chunk size default was changed.
         LA    R15,GETSYSIN+10   Now get the number that was coded.
         LR    R1,R15            Load R1 with beginning of the number.
SYSCHNUM DS    0H
         LA    R15,1(,R15)       Bump to next character.
         C     R15,=A(GETSYSIN+71)  End of SYSIN card yet?
         BH    SYSCHGNM          Yes. Go get the number.
         CLI   0(R15),C' '       Not end of card. But is it a blank?
         BE    SYSCHGNM          Yes. Then get the number.
         B     SYSCHNUM          Not a blank yet. Step up one place.
SYSCHGNM DS    0H
         SR    R15,R1            How many digits is the number?
         BCTR  R15,0             Lower it by one for EXECUTE.
         EX    R15,PACK          Copy the number to work area.
         CVB   R0,WORKA          Convert it to a binary number.
         ST    R0,CHNKSIZE       And store the value for later use.
SYSCHCLG DS    0H
         B     SYSINLUP          Go look for another card.
SYSREAD  DS    0H
         OI    READFLAG,X'01'
         MVC   FLDREADF,READFLAG     Tell FOLDEM pgm if READ only.
         B     SYSINLUP
SYSIDRCO DS    0H
         OI    IDRCFLAG,X'01'
         B     SYSINLUP
SYSINEND DS    0H                No more cards. Close SYSIN DCB.
         CLOSE SYSIN
* -------------- >>>>>>   Look for SYSIN cards            - ABOVE
SCNSYSIE DS    0H
         L     R9,SAVER9SC
         BR    R9
* - - >
PACK     PACK  WORKA,0(0,1)          <<< EXECUTED >>>
WORKA    DC    D'0'
* - - >
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
*     Routine to read a block of data from the input tape
*     and save byte counts from it, to make the AWS headers.
* ----------------------------------------------------------------- *
READBLOK DS    0H
         ST    R9,SAVER9RB        Save BAL register
         ST    R2,SAVER2R         Store work registers
         ST    R3,SAVER3R
         MVC   INECB,=F'0'        Initialize IN's ECB
         EXCP  INIOB              Read
         WAIT  ECB=INECB          Wait for Read
         TM    INCSW+4,X'01'      Was TM Read?
         BO    READTPMK           Yes
         CLI   INECB,X'7F'        Did Read complete normally?
         BNE   INERR              No -- error
         ZAP   TPMKCNT,=P'0'      Not a tape mark. Zero running count.
         AP    BLOCKCNT,=P'1'
         AP    BLOCKTOT,=P'1'
         NI    TPMKFLAG,X'FF'-X'01'    Set that Tape Mark was not read
         XC    FULLWORK,FULLWORK   Clear area completely
         MVC   HALFWORK(2),INCCW+6   Read length
         L     R2,FULLWORK           Load R2 with full low order
         MVC   HALFWORK(2),INCSW+6   Residual byte count
         L     R3,FULLWORK           Load R3 with full low order
         SR    R2,R3              R2=Actual length read
         STH   R2,BYTESCOP        Save quantity of bytes copied
         MVC   CURRBYTE(2),BYTESCOP     Save byte count of this block
         NI    ISLBLFLG,X'FF'-X'01'  Turn off "IS LABEL" flag
         OI    NWBLKFLG,X'01'        Turn on "new block" flag
         B     READNOTM           This READ was not a Tape Mark
*
READTPMK DS    0H                 This READ was a Tape Mark
         TM    TPMKFLAG,X'01'     Check if there was another TM before
         BZ    READTFST           No. First one.
         OI    TPMKFLAG,X'02'     If two in a row, flag that situation
READTFST DS    0H
         TM    TPMKFLAG,X'02'     Second Tape Mark in a row?
*
* --- >                           Null SL file is not EOT - below
         BNO   NOFIN1               Not 2 T.M. in a row. Go on.
         TM    FLAGHDRL,X'01'       Test if HDR label was last seen
         BO    NOFIN0               Yes. Must be null SL file.
         B     FIN                  Otherwise, valid 2 TMs and EOT.
NOFIN0   DS    0H
         NI    ISLBLFLG,FF-X'01'  This is data, can't be a label.
NOFIN1   DS    0H
* --- >                           Null SL file is not EOT - above
*
         AP    FILCOUNT,=P'1'     Add 1 to File Count.
         OI    TPMKFLAG,X'01'     Tell that we read a Tape Mark.
         MVC   CURRBYTE(2),=X'0000'  Show that next count is zero.
READNOTM DS    0H
* ---->     for the trace            All READ results should come here
         MVC   LINE,LINE-1           Clear output line
         MVC   LINE+1(16),READTRMS   Put in Read Trace message
         TM    TPMKFLAG,X'01'        Was last READ a Tape Mark?
         BZ    ITSABLOC              No. Mark trace as for a block.
         MVC   LINE+13(4),=C'TPMK'   Yes. Mark trace for a Tape Mark.
         B     ITSATPMK              And go farther.
ITSABLOC DS    0H
         MVC   LINE+13(4),=C'BLOC'   Show this trace was for a block
ITSATPMK DS    0H
         HEX   LINE+20,2,BYTESCOP    Show BYTES Copied field from READ
         HEX   LINE+26,2,CURRBYTE    Show Curr Bytes field for Header
         HEX   LINE+32,2,LASTBYTE    Show Prev Bytes field for Header
         HEX   LINE+37,1,TPMKFLAG    Trace Tape Mark Flag
         HEX   LINE+40,6,HEADER      Show the Header last constructed
         HEX   LINE+56,30,INAREA     Show first 20 bytes of Input Area
         TM    FLAGSYST,X'01'        Is SYSTRACE ddname present?
         BNO   NOREADT1              No. Can't print trace line.
         PUT   SYSTRACE,LINE
NOREADT1 DS    0H                    Trace is finished.
* ---->     for the trace
         L     R2,SAVER2R         Restore work registers
         L     R3,SAVER3R
         B     READBEND           and exit normally.
* -----
INERR    DS    0H                 READ error on input tape
         MVC   LINE,LINE-1        Clear print line
         TM    INCSW+4,X'02'      Unit Check?
         BZ    INERR1             No - Assume Data Check
         MVC   LINE(133),INEQC    Set Error Message
         B     INERR2             Continue
INERR1   MVC   LINE(133),INDCK    Set Error Message
INERR2   PUT   SYSPRINT,LINE      Write Error Message
         L     R2,SAVER2R         Restore work registers
         L     R3,SAVER3R         Rewind the tape, and exit.
         MVC   INCCWPT(4),=A(RUNCCW)   Get set to Rewind and Unload
         MVC   INECB,=F'0'        Initialize IN's ECB
         EXCP  INIOB              Rewind and Unload
         WAIT  ECB=INECB          Wait for Rewind and Unload
         B     WRITSUMM           Write summary of what was done,
*                                  and get out of the program.
READBEND DS    0H
         L     R9,SAVER9RB        Restore BAL register
         BR    R9
* ----------------------------------------------------------------- *
*    BAL REGISTER IS R9.
* ----------------------------------------------------------------- *
MAKEHEDR DS    0H
         ST    R9,SAVER9MH
* ----------------------------------------------------------------- *
*     We are forming the new header in the field HEADER.
*     We assume that the TAPEREAD subroutine was executed first.
*     We assume that the FLDAREA was previously saved to SAVAREA.
* ----------------------------------------------------------------- *
         MVC   HEADER(6),=XL6'00'      Start fresh.
         MVC   HDRPRVLN(2),LASTBYTE    Always HDRCURLN from last header
         MVC   HDRNSTOR(1),SAVBYTES+3     Reverse
         MVC   HDRNSTOR+1(1),SAVBYTES+2      bytes
         MVC   HDRCURLN(2),HDRNSTOR    And copy into HDRCURLN spot
MAKEWHAT DS    0H                      Manufacture the proper hdr flags
         TM    TPMKFLAG,X'01'          Has a tape mark been read?
         BO    MAKE40                  First test. Make a X'40' header
         TM    NWBLKFLG,X'01'          First chunk of current block?
         BO    MAKE80                  Yes. Turn on X'80' bit.
         TM    BUFINISH,X'01'          Last chunk of current block?
         BO    MAKE20                  Yes. Turn on X'20' bit.
         B     MAKE00                  No. Don't turn on any flag bits.
MAKE80   DS    0H
         OI    HDRFLAG1,X'80'          Turn on X'80'
         B     MAKE20                  And see if X'20' also, or not.
MAKE00   DS    0H                      No HDRFLAG1 bits to be turned on
         B     MAKEHDEN                And just get out.
MAKE20   DS    0H
         TM    BUFINISH,X'01'          Test again for last chunk.
         BZ    MAKEHDEN                It isn't, so only X'80' is on.
         OI    HDRFLAG1,X'20'          It is. So turn on X'20'.
         B     MAKEHDEN
MAKE40   DS    0H                      Tape mark has been read.
         MVC   HDRCURLN(2),=X'0000'    Next header is right after this.
         MVI   HDRFLAG1,X'40'          HDRFLAG1 has to be X'40'
MAKEHDEN DS    0H
         MVC   LASTBYTE,HDRCURLN       Store to insert in next HDRPRVLN
         AP    OUTHDRS,=P'1'           Count this header we've made.
*----------------------------------------------------------------- *
*   Now that we've made a header, we count how many of each type.
*----------------------------------------------------------------- *
KINDAHDR DS    0H
         CLI   HDRFLAG1,X'00'         IS THIS A MIDDLE CHUNK IN BLOCK?
         BNE   KCHKBEG                NO. TEST IF BEG CHUNK OF BLOCK
         AP    OUTTYPE3,=P'1'         YES. COUNT THIS TYPE
         B     KINDAHEN               IF IT'S 00 IT'S NOT ANOTHER TYPE
KCHKBEG  DS    0H
         TM    HDRFLAG1,X'80'         BEGINNING OF BLOCK?
         BNO   KCHKEND                NO. CHECK FURTHER FOR END OF BLK.
         AP    OUTTYPE1,=P'1'         YES. COUNT THIS TYPE
KCHKEND  DS    0H
         TM    HDRFLAG1,X'20'         END OF BLOCK?
         BNO   KINDAH40               NO. CHECK IF END OF FILE
         AP    OUTTYPE2,=P'1'         YES. COUNT THIS TYPE
KINDAHA0 DS    0H
         CLI   HDRFLAG1,X'A0'         BOTH BEGINNING AND END OF BLOCK?
         BNE   KINDAH40               NO. TEST FOR EOF HEADER.
         AP    OUTTYPE5,=P'1'         YES. COUNT IT FOR REPORTING.
         B     KINDAHEN               AND DON'T TEST MORE BITS.
KINDAH40 DS    0H
         TM    HDRFLAG1,X'40'         END OF FILE HEADER?
         BNO   KINDAHEN               NO. NOT A TYPE THAT WE KNOW.
         AP    OUTTYPE4,=P'1'         YES. COUNT THIS TYPE
*
KINDAHEN DS    0H
         TM    FLAGSYST,X'01'         ARE WE PRINTING THE TRACE REPORT?
         BNO   NOSYSTR1               TAKE APPROPRIATE ACTION
         MVC   OUTLINE,OUTLINE-1      CLEAR PRINT LINE
         MVC   OUTLINE+2(4),=C'hdr:'
         HEX   OUTLINE+8,6,HEADER     FLDAREA at MAKEHEDR time display
         HEX   OUTLINE+28,4,FLDSCARD                            .
         HEX   OUTLINE+38,4,FLDECARD                            .
         HEX   OUTLINE+48,4,FLDOFFST                            .
         HEX   OUTLINE+58,4,FLDBYTES                            .
         HEX   OUTLINE+68,4,FLDBYTOT                            .
         HEX   OUTLINE+78,4,FLDBYMVD                            .
         HEX   OUTLINE+88,4,FLDBUFFR                            .
         HEX   OUTLINE+98,4,FLDBSTRT                            .
         HEX   OUTLINE+108,7,FLDOUTCT                           .
         HEX   OUTLINE+124,1,FLDREADF
         HEX   OUTLINE+22,1,HDRFLAG1                            .
         PUT   SYSTRACE,OUTLINE
NOSYSTR1 DS    0H
MAKEHEND DS    0H
         L     R9,SAVER9MH
         BR    R9
* ----------------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
*                                                           *
*    FOLDBUFF ROUTINE  -  CALL TO FOLDEM SUBPROGRAM         *
*                                                           *
*    All FLDAREA field required for call have to be         *
*    filled in:                                             *
*                                                           *
*    FLDSCARD - Initialized to OUTCARD at beg of program    *
*    FLDECARD - Initialized to OUTCARD+80                   *
*    FLDOFFST - Initialized to 0, updated by each call      *
*    FLDBYTES - Set before each call                        *
*    FLDBYTOT - Set before each call                        *
*    FLDBYMVD - Calculated by FOLDEM, caller reinitializes  *
*    FLDBUFFR - Initialized to buffer, updated by FOLDEM    *
*    FLDBSTRT - Start of input buffer                       *
*    FLDOUTCT - Initialized to P'0', updated by FOLDEM      *
*    FLDREADF - READFLAG, copied into FLDAREA control blk   *
*                                                           *
* --------------------------------------------------------- *
FOLDBUFF DS    0H
         ST    R9,SAVER9FB              Save BAL register
         MVC   LINE,LINE-1
*        MVC   LINE+1(8),=C'BEFCALL-'   Diagnostic picture before call
*        BAL   R9,FLDIMAGE
         LA    R1,FLDAREA
         L     R15,=V(FOLDEM)           Entry point of FOLDEM program
         BALR  R14,R15                  Call it.
*                                       Copy back FLDAREA from FOLDEM
         ST    R1,NEWFLDA               Save new FLDAREA address
         MVC   FLDAREA(FLDLENTH),0(R1)  Overlay new FLDAREA over ours
         MVC   LINE,LINE-1
*        MVC   LINE+1(8),=C'AFTCALL-'   Diagnostic picture after call
*        BAL   R9,FLDIMAGE
FOLDBUFE DS    0H
         L     R9,SAVER9FB              Restore BAL register
         BR    R9                       Return to caller
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
* --------------------------------------------------------- *
FLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently
*
         ST    R9,SAVER9FI
         HEX   LINE+10,4,FLDSCARD
         HEX   LINE+20,4,FLDECARD
         HEX   LINE+30,4,FLDOFFST
         HEX   LINE+40,4,FLDBYTES
         HEX   LINE+50,4,FLDBYTOT
         HEX   LINE+60,4,FLDBYMVD
         HEX   LINE+70,4,FLDBUFFR
         HEX   LINE+80,4,FLDBSTRT
         HEX   LINE+90,7,FLDOUTCT
         HEX   LINE+106,1,FLDREADF
         PUT   SYSPRINT,LINE
         MVC   LINE,LINE-1
         L     R9,SAVER9FI
         BR    R9
* --------------------------------------------------------- *
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
*   R2 HAS TO CONTAIN THE FULLWORD BYTE COUNT FOR THE LAST READ
*   R3 HAS TO POINT TO THE DOUBLEWORD COUNTER TO BE INCREMENTED
* --------------------------------------------------------- *
ADDCOUNT DS    0H                  ADD BYTE COUNT SUBROUTINE
         ST    R9,SAVER9AD         Save BAL register
         STM   R4,R5,SAVEADDC      Save work registers
         L     R4,0(,R3)           Load high order counter
         L     R5,4(,R3)           Load low order counter
         AR    R5,R2               Add to byte count
         BNO   ADDCNOOV            No overflow, then branch
         LA    R4,1(,R4)           else, overflow to high word
         X     R5,=X'7FFFFFFF'     Get rid of sign bit
ADDCNOOV DS    0H
         ST    R4,0(,R3)           Put updated counter in storage
         ST    R5,4(,R3)           Put updated counter in storage
         LM    R4,R5,SAVEADDC      Restore work registers
ADDCOUNE DS    0H                  END OF ROUTINE - RETURN
         L     R9,SAVER9AD         Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
LABELCHK DS    0H         Check for the presence of tape labels
*                         and set label flags, accordingly,
*                         in the LBLFLAG byte.
*
*              X'01'    HDR1 HAS BEEN SEEN
*              X'02'    HDR2 HAS BEEN SEEN
*              X'04'    VOL1 HAS BEEN SEEN
*              X'08'    HDR1 IS FROM AN INITTED TAPE
*              X'10'    EOF1 HAS BEEN SEEN
*              X'20'    EOF2 HAS BEEN SEEN
*              X'40'    EOV1 HAS BEEN SEEN
*              X'80'    EOV2 HAS BEEN SEEN
*
* --------------------------------------------------------- *
         ST    R9,SAVER9LB          Save BAL register
         NI    ISLBLFLG,FF-X'01'    Turn off "Is Label" flag at start
         CLC   INAREA(4),=C'VOL1'   Is this a VOL1 ?
         BE    CVOL1                Process THE VOL1
         CLC   INAREA(4),=C'HDR1'   Is this a HDR1 ?
         BE    CHDR1                Process HDR1
         CLC   INAREA(4),=C'HDR2'   This a HDR2 ?
         BE    CHDR2                Process HDR2
         CLC   INAREA(4),=C'EOF1'   This an EOF1 ?
         BE    CEOF1                Process EOF1
         CLC   INAREA(4),=C'EOF2'   This an EOF2 ?
         BE    CEOF2                Process EOF2
         CLC   INAREA(4),=C'EOV1'   This an EOV1 ?
         BE    CEOV1                Process EOV1
         CLC   INAREA(4),=C'EOV2'   This an EOV2 ?
         BE    CEOV2                Process EOV2
         CLC   INAREA(3),=C'UHL'    This a User Header Label?
         BE    CUHL                 Process UHL
         CLC   INAREA(3),=C'UTL'    This a User Trailer Label?
         BE    CUTL                 Process UTL
         B     NOTLABEL             80 byte record is not an IBM SL
*        ------------------------------------------------------ *
CVOL1    DS    0H                   PROCESS VOL1 LABEL
* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRCV             NO. SKIP ROUTINE.
         MVI   INAREA+35,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRCV DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN VOL1  ----  ABOVE
         OI    LBLFLAG,X'04'        YES. FLAG VOL1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
* ----- >    CHANGE OUTPUT VOLUME NAME - below
         CLC   SVNEWVOL(6),=C'      '    IS SVNEWVOL BLANK?
         BE    NOCHGVOL                  YES. DON'T CHANGE.
         LA    R1,INAREA                 Point to INAREA
         MVC   4(6,R1),SVNEWVOL          NO. PLUG IN NEW VALUE.
         MVC   MESSAG13+30(6),SVNEWVOL   AND MOVE IT TO THE MESSAGE.
         PUT   SYSPRINT,MESSAG13         VOLSER overridden message.
         TM    FLAGSYST,X'02'
         BZ    NCHGMOVD
         PUT   SYSMOVED,MESSAG13
NCHGMOVD DS    0H
         TM    FLAGSYST,X'04'            SYSFILES here?
         BZ    NCHGFILE                  Nope. Skip a PUT to it.
         PUT   SYSFILES,MESSAG13         VOLSER overridden message.
         MVC   OUTLINE,OUTLINE-1         Blank line to separate
         PUT   SYSFILES,OUTLINE             from the rest of output.
NCHGFILE DS    0H
NOCHGVOL DS    0H                        Kludge extra blank like
         TM    FLAGSYST,X'04'            Is SYSFILES here?
         BZ    KLUDGE01                  Nope. No PUTs to it.
         CLC   SVNEWVOL(6),=C'      '    VOLSER not being overridden?
         BNE   KLUDGE01                  Is overridden, no extra blank.
         MVC   OUTLINE,OUTLINE-1         Not overridden. Kludge a blank
         PUT   SYSFILES,OUTLINE
KLUDGE01 DS    0H
* ----- >    CHANGE OUTPUT VOLUME NAME - above
         B     LABCHEND
CHDR1    DS    0H
         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS
         OI    LBLFLAG,X'01'        FLAG HDR1 SEEN.
         CLC   INAREA+4(23),ZERO23  WAS TAPE INITTED?
         BNE   CHDR1A               NO. THIS IS A HDR1 FOR DATASET
         OI    LBLFLAG,X'08'        YES. ZERO DSN AND VOLSER HERE
CHDR1A   OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CHDR2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRH2             NO. SKIP ROUTINE.
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRH2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRH2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN HDR2  ----  ABOVE
         NI    LBLFLAG,X'0F'        TURN OFF EOV, EOF FLAGS IF HDR2
         OI    LBLFLAG,X'02'        FLAG HDR2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOF1    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF1
         OI    LBLFLAG,X'10'        FLAG EOF1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOF2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRF2             NO. SKIP ROUTINE.
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRF2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRF2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOF2  ----  ABOVE
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOF2
         OI    LBLFLAG,X'20'        FLAG EOF2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOV1    DS    0H
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV1
         OI    LBLFLAG,X'40'        FLAG EOV1 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CEOV2    DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  BELOW
         TM    IDRCFLAG,X'01'       ARE WE TURNING OFF IDRC INDICATOR?
         BZ    CLRIDRV2             NO. SKIP ROUTINE.           \
         CLI   INAREA+34,C'P'       IS IDRC INDICATOR THERE?
         BNE   CLRIDRV2
         MVI   INAREA+34,C' '       BLANK THE INDICATOR IN THE VOL1
CLRIDRV2 DS    0H
* -->>>>>>            CLEAR IDRC INDICATOR IN EOV2  ----  ABOVE
         NI    LBLFLAG,X'F8'        TURN OFF HDR FLAGS IF EOV2
         OI    LBLFLAG,X'80'        FLAG EOV2 SEEN.
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
*- USER LABEL HANDLING CODE  ------  BELOW  --------------- *
CUHL     DS    0H                   HANDLE USER HEADER LABELS
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
CUTL     DS    0H                   HANDLE USER TRAILER LABELS
         OI    ISLBLFLG,X'01'       INDICATE WE JUST READ A LABEL
         B     LABCHEND
*- USER LABEL HANDLING CODE  ------  ABOVE  --------------- *
NOTLABEL NI    ISLBLFLG,FF-X'01'    TURN OFF "IS LABEL" FLAG
LABCHEND DS    0H                   Return to caller
         L     R9,SAVER9LB          Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
SUMMREPT DS    0H                        Write Summary Totals
         ST    R9,SAVER9SR               Save BAL Register
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+14(21),=C'AWS HEADER STATISTICS'
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG01
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),FLDOUTCT   NUMBER OF INPUT RECORDS READ
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG02
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTHDRS    NUMBER OF HEADERS ENCOUNTERED
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG03
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE1   BEGINNING OF BLOCK HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG04
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE2   END OF BLOCK HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG05
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE3   MIDDLE OF BLOCK HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG06
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE4   END OF FILE HEADERS
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE(34),PRMSG07
         MVC   OUTLINE+36(18),EDPAT
         ED    OUTLINE+36(18),OUTTYPE5   X'A0' HEADERS - BEG and END
         PUT   SYSPRINT,OUTLINE
* >---->                                 Display tape total counts
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         MVC   OUTLINE+14(21),=C'TAPE BYTE COUNT STATS'
         PUT   SYSPRINT,OUTLINE
         MVC   OUTLINE,OUTLINE-1
         PUT   SYSPRINT,OUTLINE
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG03       Total bytes folded for tape
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTMH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31               MULT BY 2 TO THE 31ST
         L     R4,DBOUTML                LOAD REG WITH LOW ORDER
         CVD   R4,DWORD                  CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD               AND ADD IT IN
         ED    FILEBYTE,QWORD+6          DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM01
         PUT   SYSFILES,CNTLINE
NOSUMM01 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG04       Total bytes read for tape
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM02
         PUT   SYSFILES,CNTLINE
NOSUMM02 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG05       Total bytes read for labels
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,LBINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM03
         PUT   SYSFILES,CNTLINE
NOSUMM03 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG06       Total bytes read for data
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DAINH
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM04
         PUT   SYSFILES,CNTLINE
NOSUMM04 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG08       Total blocks read for tape
         MVC   FILEBYTE,BYTESPAT
         MVC   CNTLINE+54(11),BLOKPAT
         ED    CNTLINE+54(11),BLOCKTOT+2
         MVC   CNTLINE+65(6),=C'Blocks'
         PUT   SYSPRINT,CNTLINE
* >---->
         TM    FLAGSYST,X'04'
         BNO   NOSUMM05
         PUT   SYSFILES,CNTLINE
NOSUMM05 DS    0H
* >---->
SUMMREND DS    0H                  END OF ROUTINE - RETURN
         L     R9,SAVER9SR         Restore BAL register
         BR    R9
* --------------------------------------------------------- *
*    BAL REGISTER IS R9.
* --------------------------------------------------------- *
REPTFILE DS    0H       Routine to write block and byte counts
*                       for each file in the SYSFILES ddname.
* --------------------------------------------------------- *
*----------->>
         ST    R9,SAVER9RF
*--->                   Block counts first  -  below
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG07
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   CNTLINE+54(11),BLOKPAT
         ED    CNTLINE+54(11),BLOCKCNT+2
         MVC   CNTLINE+65(6),=C'Blocks'
         MVC   CNTLINE+90(11),BLOKPAT
         ED    CNTLINE+90(11),BLOCKTOT+2
         MVC   CNTLINE+102(10),=C'Cum Blocks'
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE00
         PUT   SYSFILES,CNTLINE
NOFILE00 DS    0H
* >---->
*--->                   Block counts first  -  above
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG01
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTFMH        Bytes folded counts for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTFML        LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
         L     R4,SAVER4Q
* >--->
         TM    ISLBLFLG,X'01'
         BO    DISLABLS
         MVC   DATBYTES,BYTESPAT
         L     R4,DAINH           Data bytes written cumulative to here
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DAINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    DATBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(38),DATDISPL
         B     DISPDATA
* >--->
DISLABLS DS    0H
         MVC   LABBYTES,BYTESPAT
         L     R4,LBINH           Label bytes written, cumulative
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,LBINL           LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    LABBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(38),LABDISPL
         B     DISPDATA
* >--->
DISPDATA DS    0H
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE01
         PUT   SYSFILES,CNTLINE
NOFILE01 DS    0H
* >---->
         MVC   CNTLINE,CNTLINE-1
         MVC   CNTLINE(38),CTMSG02
         MVC   CNTLINE+29(9),FILEPAT
         ED    CNTLINE+29(9),FILCOUNT+3
         MVC   FILEBYTE,BYTESPAT
         ST    R4,SAVER4Q
         L     R4,DBOUTFH         Bytes written for this file
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTFL         LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    FILEBYTE,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+38(32),FILEBYT
* >--->
         CLC   DBOUTF(8),DBOUTFM
         BE    RIGHTBYT
         MVI   CNTLINE+72,C'*'
RIGHTBYT DS    0H
* >--->
         MVC   CUMBYTES,BYTESPAT
         L     R4,DBOUTH          Bytes written, cumulative
         CVD   R4,DWORD
         ZAP   QWORD,DWORD
         MP    QWORD,TWO31        MULT BY 2 TO THE 31ST
         L     R4,DBOUTL          LOAD REG WITH LOW ORDER
         CVD   R4,DWORD           CONVERT LOW ORDER TO PACKED
         AP    QWORD,DWORD        AND ADD IT IN
         ED    CUMBYTES,QWORD+6   DISPLAY COUNT IN LINE
         MVC   CNTLINE+74(43),CUMDISPL
* >--->
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE02
         PUT   SYSFILES,CNTLINE
NOFILE02 DS    0H
         L     R4,SAVER4Q
         MVC   CNTLINE,CNTLINE-1
         TM    FLAGSYST,X'04'     SYSFILES DD NAME THERE?
         BNO   NOFILE03
         PUT   SYSFILES,CNTLINE
NOFILE03 DS    0H
*----------->>
REPTFEND DS    0H
         L     R9,SAVER9RF
         BR    R9
         EJECT
* ----------------------------------------------------------------- *
*      CCWs and IOB for the EXCP operations.
* ----------------------------------------------------------------- *
*              read,addr of data,flags,64K bytes
RUNCCW   DC    X'0F',AL3(INAREA),X'6000',X'0000'     Rewind Unload CCW
         DC    X'03',AL3(INAREA),X'2000',X'0000'     NOP CCW
INCCW    DC    X'02',AL3(INAREA),X'2000',X'FFFF'     Read CCW
INECB    DC    F'0'
INIOB    DC    X'02000000'
         DC    A(INECB)
INCSW    DC    2F'0'
INCCWPT  DC    A(INCCW)
INDCBPT  DC    A(TAPIN)
         DC    F'0'
         DC    X'00010000'
         DC    XL44'00'            Padding
         SPACE 3
* ----------------------------------------------------------------- *
         ENTRY AWSOUT
AWSOUT   DCB   DDNAME=AWSOUT,MACRF=PM,DSORG=PS,LRECL=80
TAPIN    DCB   MACRF=(E),DDNAME=TAPIN,DEVD=TA,DSORG=PS,RECFM=U
         ENTRY SYSPRINT
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSTRACE DCB   DDNAME=SYSTRACE,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSMOVED DCB   DDNAME=SYSMOVED,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSFILES DCB   DDNAME=SYSFILES,DSORG=PS,MACRF=PM,LRECL=133,RECFM=FBA
SYSIN    DCB   MACRF=GM,DDNAME=SYSIN,DSORG=PS,RECFM=FB,LRECL=80,       X
               EODAD=SYSINEND
         DC    CL8' '
FF       EQU   X'FF'
* ----------------------------------------------------------------- *
*
* AWSTAPE BLOCK HEADER
*
* ----------------------------------------------------------------- *
HEADER   DS    0CL6                     BLOCK HEADER
HDRCURLN DC    XL2'0000'                CURRENT BLOCK LENGTH
HDRPRVLN DC    XL2'0000'                PREVIOUS BLOCK LENGTH
HDRFLAG1 DC    X'00'                    FLAGS BYTE 1...
HDRF1BOR EQU   X'80'                    ...BEGINNING OF RECORD
HDRF1TMK EQU   X'40'                    ...TAPE MARK
HDRF1EOR EQU   X'20'                    ...END OF RECORD
HDRFLAG2 DC    X'00'                    FLAGS BYTE 2
*
         DC    XL80'00'                 PADDING
OUTHEADR DC    XL6'00'
* ----------------------------------------------------------------- *
         DC    XL12'00'                 PADDING
HALFZERO DC    XL2'00'
         DC    XL12'00'                 PADDING
HDRNSTOR DC    XL2'00'             STORE BYTES IN NEXT BLOCK - BIF
HDRPSTOR DC    XL2'00'             STORE BYTES IN PREV BLOCK - BIF
         DC    XL12'00'                 PADDING
BYTESCOP DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT
CURRBFUL DS    0F
         DC    H'0'
CURRBYTE DC    H'0'           CURRENT NUMBER OF BYTES COPIED FROM INPUT
LASTBFUL DS    0F
         DC    H'0'
LASTBYTE DC    H'0'           LAST NUMBER OF BYTES COPIED FROM INPUT
PARTBFUL DS    0F
         DC    H'0'
PARTBYTE DC    H'0'           PARTIAL LAST BYTES ON CHUNKED INPUT
ZEROCARD DC    80X'00'
* -------------------------------------------- *
* ---------- *      F L A G S     * ---------- *
* -------------------------------------------- *
* ---------- *
READFLAG DC    X'00'         This run is "READ ONLY"  ?
*              X'01'         Yes, read only.
* ---------- *
NWBLKFLG DC    X'00'         We have just read a new block.
*              X'01'         Turned off after first chunk write.
* ---------- *
IDRCFLAG DC    X'00'         This run is "IDRC Fix"  ?
*              X'01'         Turn off IDRC indicator
* ---------- *
FLAGCHNK DC    X'00'          FLAG TO SHOW IF CHUNK SIZE WAS CODED
*              X'01'          CHUNK SIZE IS NOT BLANK
* ---------- *
FLAGSYST DC    X'00'          FLAG TO SHOW IF OPTIONAL DD'S THERE
*              X'01'          //SYSTRACE DD IS THERE
*              X'02'          //SYSMOVED DD IS THERE
*              X'04'          //SYSFILES DD IS THERE
*              X'08'          //SYSIN    DD IS THERE
* ---------- *
CHNKFLAG DC    X'00'          ARE WE CHUNKING THE BLOCKS?
*              X'01'          BUFFER BYTES BIGGER THAN CHUNK SIZE
* ---------- *
BUFINISH DC    X'00'          Have we finished folding entire buffer?
*              X'01'          Yes. We are now finishing the buffer.
* ---------- *
LBLFLAG  DC    X'00'    FLAG WHEN TAPE LABELS ARE BEING READ IN
*              X'01'    HDR1 HAS BEEN SEEN
*              X'02'    HDR2 HAS BEEN SEEN
*              X'04'    VOL1 HAS BEEN SEEN
*              X'08'    HDR1 IS FROM AN INITTED TAPE
*              X'10'    EOF1 HAS BEEN SEEN
*              X'20'    EOF2 HAS BEEN SEEN
*              X'40'    EOV1 HAS BEEN SEEN
*              X'80'    EOV2 HAS BEEN SEEN
* ---------- *
ISLBLFLG DC    X'00'          FLAG INDICATING WE JUST READ A LABEL
*              X'00'          DATA IS NOT A LABEL
*              X'01'          DATA IS A LABEL
* ---------- *
TPMKFLAG DC    X'00'          Flag that we encountered a Tape Mark
*              X'01'          We just read a Tape Mark
*              X'02'          We previously read a Tape Mark
* ---------- *
FLAGHDRL DC    X'00'          Header label flag - Last label was a hdr
*              X'01'          EOT HEADER is following a HDR1 or HDR2
* ---------- *
* -------------------------------------------- *
FULLWORK DS    0F
FULLHIGH DC    H'0'
HALFWORK DC    H'0'                HALFWORD WORK AREA
         DC    2F'0'               Padding
FOLDBREG DS    0F                  Fullword - no of bytes to fold
FOLDHIGH DC    XL2'00'             High order - should be zeros
HDRFULL  DS    0F                  LOOK AT HDRLENG AS A FULLWORD
HDRFILL  DC    XL2'00'             FILLER TO MAKE A FULLWORD
HDRLENG  DC    XL2'00'             HEADER LENGTH UNREVERSED
HDRPFUL  DS    0F                  LOOK AT PREVIOUS AS A FULLWORD
HDRPRVF  DC    XL2'00'
HDRPREV  DC    XL2'00'             PREVIOUS BLOCK LENGTH UNREVERSED
HDRFULLS DS    0F                  LOOK AT HDRLENG AS A FULLWORD
HDRLENFL DC    XL2'00'
HDRLENGS DC    XL2'00'             SAVED LENGTH VALUE FROM HEADER
HDRPFULS DS    0F                  LOOK AT PREVIOUS AS A FULLWORD
HDRPRVFL DC    XL2'00'
HDRPREVS DC    XL2'00'             SAVED PREVIOUS VALUE FROM HEADER
OUTCCWST DC    XL2'00'
         DC    XL2'00'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)      MOVE BYTE
         UNPK  0(3,R15),1(2,R15)   UNPACK
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)         INCREMENT OUTPUT PTR
         LA    R1,1(,R1)           INCREMENT INPUT PTR
         BCT   R0,HEX              DECREMENT LENGTH, THEN LOOP
         MVI   0(R15),C' '         BLANK THE TRAILING BYTE
         BR    R4                  RETURN TO CALLER
HEXTAB   DC    C'0123456789ABCDEF' TRANSLATE TABLE
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
DB       DC    D'0'          DOUBLE-WORD WORK AREA              \
DB2      DC    0D'0',PL8'0'  DOUBLE-WORD WORK AREA              \
*  TABLE OF DAYS IN PRIOR MONTH                                 \
DATETABL DC   H'0,31,59,90,120,151,181,212,243,273,304,334,365' \
SVNEWVOL DC    CL6' '              SAVED NEW VOLUME
CHNKSIZE DC    F'65535'            Default is maximum halfword
LASTLINE DS    0CL80
LASTHX00 DC    80X'00'
HEXSAVE  DS    3F                  SAVE FOR HEX MACRO
DWORD    DC    D'0'
QWORD    DS    PL16
TWO31    DC    P'2147483648'       2 TO THE 31ST
OUTHDRS  DC    PL7'0'
OUTTYPE1 DC    PL7'0'
OUTTYPE2 DC    PL7'0'
OUTTYPE3 DC    PL7'0'
OUTTYPE4 DC    PL7'0'
OUTTYPE5 DC    PL7'0'
FILCOUNT DC    PL7'0'
BLOCKCNT DC    PL7'0'
BLOCKTOT DC    PL7'0'
TPMKCNT  DC    PL7'0'
DECVALUE DS    CL8
FILEPAT  DC    X'402020202020202120'
BLOKPAT  DC    X'4020202020202020212020'
EDPAT    DC    X'40206B2020206B2020206B2020206B202120'
BYTESPAT DC    X'40206B2020206B2020206B2020206B2020206B2020206B202120'
FILEBYT  DS    0CL32
FILEBYTE DC    C' 9,999,999,999,999,999,999'
         DC    C' Bytes'
CUMDISPL DS    0CL43
CUMBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Total Bytes'
LABDISPL DS    0CL38
LABBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Labels'
DATDISPL DS    0CL38
DATBYTES DC    C' 9,999,999,999,999,999,999'
         DC    C'  Cum Data  '
*
SVBEGCRD DS    F
SVENDCRD DS    F
SVBFAREA DS    F                Address of input buffer
*
SAVER2R  DS    F                Save work regs during tape read.
SAVER3R  DS    F                Save work regs during tape read.
SAVER4B  DS    F                Register Save for HEX routine
SAVER4Q  DS    F                Register Save for byte count reperting
SAVEFOLD DS    6F               Register Save for FOLDEM routine
SAVEADDC DS    3F               Register Save for ADDCOUNT routine
SAVEMOVE DS    3F               REGISTER SAVE FOR FOLDEM ROUTINE
SAVER9AD DS    F                Register Save for ADDCOUNT routine
SAVER9RB DS    F                Register Save for READBLOK routine
SAVER9RF DS    F                Register Save for REPTFILE routine
SAVER9LB DS    F                Register Save for LABELCHK routine
SAVER9SR DS    F                Register Save for SUMMREPT routine
SAVER9FB DS    F                Register Save for FOLDBUFF routine
SAVER9FI DS    F                Register Save for FLDIMAGE routine
SAVER9SC DS    F                Register Save for SCNSYSIN routine
SAVER9MH DS    F                Register Save for MAKEHEDR routine
NEWFLDA  DS    F
HDRSIZE  DC    F'6'             SIZE OF A HEADER
SVBEGDAT DS    F
*  -----------------
ZERO23   DC    23C'0'         TEST FOR IEHINITTED HDR1
*  -----------------     JFCB if we'll need RDJFCB later - not used now
JFCB1    DC    X'87'
         DC    AL3(INFMJFCB)
         IEFJFCBN LIST=YES
         DC    C' '
*
*  -----------------            Summary Totals Message Texts
PRMSG01  DC    CL34'     TOTAL NUMBER OF RECORDS OUT: '
PRMSG02  DC    CL34'     TOTAL NUMBER OF HEADERS OUT: '
PRMSG03  DC    CL34'     TOTAL BEG BLOCK HEADERS    : '
PRMSG04  DC    CL34'     TOTAL END BLOCK HEADERS    : '
PRMSG05  DC    CL34'     TOTAL MID BLOCK HEADERS    : '
PRMSG06  DC    CL34'     TOTAL END OF FILE HEADERS  : '
PRMSG07  DC    CL34'     TOTAL BEGIN AND END BLOCK  : '
*
*  -----------------            Byte Count Message Texts
CTMSG01  DC    CL38'     BYTES FOLDED FOR FILE:           '
CTMSG02  DC    CL38'     BYTES  READ  FOR FILE:           '
CTMSG03  DC    CL38'     TOTAL BYTES FOLDED FOR TAPE  :   '
CTMSG04  DC    CL38'     TOTAL BYTES  READ  FOR TAPE  :   '
CTMSG05  DC    CL38'     TOTAL BYTES  READ  FOR LABELS:   '
CTMSG06  DC    CL38'     TOTAL BYTES  READ  FOR DATA  :   '
CTMSG07  DC    CL38'     BLOCKS READ FOR  FILE:           '
CTMSG08  DC    CL38'     TOTAL BLOCKS READ  FOR TAPE  :   '
*
*  -----------------            Header Message Texts
MESSAGE1 DC    CL133'1VTT2DISK - REAL TAPE TO FB-80 AWS CONVERSION PROG-
               RAM  '
MESSAGE2 DC    CL133'1VTT2DISK  -  AWS TAPE HEADER TRACE REPORT  '
MESSAGE3 DC    CL133'1VTT2DISK - TAPE TO AWS DATA MOVE - TRACE AND ERRO-
               R REPORT  '
MESSAGE4 DC    CL133'1VTT2DISK - TAPE TO AWS FILE REPORT - READ AND FOL-
               D STATS  '
MESSAGE5 DC    CL133'        A TRACE IS TAKEN EVERY TIME THAT A HEADER -
               IS CREATED BY THE PROGRAM, IN MAKING AN AWS FORMAT TAPE.-
               '
MESSAGE6 DC    CL133'        THE FLDAREA (FOLDEM AREA CONTROL BLOCK) FI-
               ELDS ARE SHOWN AS OF THE TIME THE HEADER IS JUST FORMED.-
               '
MESSAGE7 DS    0CL133
         DC    CL8'  hdr:  '
         DC    CL12'HEADER TEXT '
         DC    CL1' '
         DC    CL4'TYPE'
         DC    CL3' '
         DC    CL10'FLDSCARD'
         DC    CL10'FLDECARD'
         DC    CL10'FLDOFFST'
         DC    CL10'FLDBYTES'
         DC    CL10'FLDBYTOT'
         DC    CL10'FLDBYMVD'
         DC    CL10'FLDBUFFR'
         DC    CL10'FLDBSTRT'
         DC    CL14'FLDINRCD'
         DC    CL11' '
MESSAGE8 DC    CL133'        IT IS APPROPRIATE THAT A TRACE BE TAKEN AT-
                EACH READ OF THE TAPE, AND ALSO WHEN THE HEADERS ARE MA-
               DE. '
MESSAGE9 DC    CL133'        AS OF RELEASE 1.12 OF VTT2DISK, THE SYSMOV-
               ED REPORT IS NOT NECESSARY.  IF YOU NEED TRACE DATA NOW,-
                 '
MESSAG10 DC    CL133'        ENOUGH DATA IS AVAILABLE IN THE SYSTRACE R-
               EPORT.  BOTH "TAPE READ" AND "FOLD DATA" ARE AVAILABLE T-
               HERE.'
MESSAG11 DC    CL133'        IF YOU NEED ADDITIONAL TRACE DATA AND YOU -
               HAVE SOURCE CODE, THEN UNCOMMENT THE "BEFCALL-" AND "AFT-
               CALL-" '
MESSAG12 DC    CL133'        INVOCATIONS OF THE FLDIMAGE SUBROUTINE, WH-
               ICH ARE:  BAL   R9,FLDIMAGE  INSTRUCTION LINES.         -
                    '
MESSAG13 DC    CL133'    VOLSER Overridden to:    '
MESSAG14 DC    CL133'    Chunk Size is set to:    '
*  -----------------            Error Message Texts
ERRMESS1 DC    CL133'    OFFSET ERROR           '
INEQC    DC    C' *********** EQUIPMENT CHECK ON INPUT -- COPY '
         DC    C'TERMINATED '
         DC    76C'*'
INDCK    DC    C' ********** DATA CHECK ON INPUT -- COPY TERMINATED '
         DC    82C'*'
*  -----------------            Trace Message Texts
READTRMS DC    CL16'READ TRACE:     '
FOLDTRMS DC    CL16'FOLD TRACE:     '
MHDRTRMS DC    CL16'MAKEHEDR TRACE: '
OSETTRMS DC    CL16'OFFSET TRACE:   '
BBLKTRMS DC    CL16'BLOCK TRACE:    '
*    ------------------------ >   Output Line Buffers  -  below
         DC    C' '
CNTLINE  DC    CL133' '
         DC    C' '
OUTLINE  DC    CL133' '
         DC    C' '
LINE     DC    CL133' '           For error messages
         DC    C' '
PRTLINE  DC    CL133' '
         DC    C' '
MSGLINE1 DC    CL133' '           For READ only message
         DC    C' '
MSGLINE2 DC    CL133' '           For IDRC remove message
*    ------------------------ >   Output Line Buffers  -  above
         LTORG
SAVEHDR  DC    XL6'000000000000'
EOTMARK  DC    XL6'000000004000'
* - - - - >
*
FLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
FLDSCARD DC    F'0'         Start address of 80-byte card
FLDECARD DC    F'0'         End address of 80-byte card
FLDOFFST DC    F'0'         OFFSET of data in the card
FLDBYTES DC    F'0'         Number of bytes to be folded now
FLDBYTOT DC    F'0'         Batch total of bytes left to move
FLDBYMVD DC    F'0'         Number of bytes folded now
FLDBUFFR DC    F'0'         Current data start address
FLDBSTRT DC    F'0'         Original start data address
FLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records
FLDREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
FLDLENTH EQU   *-FLDAREA
*
* - - - - >
*         Saved Copy of FLDAREA Control Block
* - - - - >
*
SAVAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
SAVSCARD DC    F'0'         Start address of 80-byte card
SAVECARD DC    F'0'         End address of 80-byte card
SAVOFFST DC    F'0'         OFFSET of data in the card
SAVBYTES DC    F'0'         Number of bytes to be folded now
SAVBYTOT DC    F'0'         Batch total of bytes left to move
SAVBYMVD DC    F'0'         Number of bytes folded now
SAVBUFFR DC    F'0'         Current data start address
SAVBSTRT DC    F'0'         Original start data address
SAVOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records
SAVREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
SAVLENTH EQU   *-SAVAREA
*
* - - - - >
*    ------------------------ >   Byte Count Save Areas - below
*
*                          -- These are doubleword counters --
*
DBOUTF   DS    0D          BYTE COUNT SAVE AREA FOR INPUT FILE READ
DBOUTFH  DC    F'0'
DBOUTFL  DC    F'0'
DBOUTFM  DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT FILE FOLDED
DBOUTFMH DC    F'0'
DBOUTFML DC    F'0'
DBOUT    DS    0D          BYTE COUNT SAVE AREA FOR INPUT TOTAL READ
DBOUTH   DC    F'0'
DBOUTL   DC    F'0'
DBOUTM   DS    0D          BYTE COUNT SAVE AREA FOR OUTPUT TOTAL FOLDED
DBOUTMH  DC    F'0'
DBOUTML  DC    F'0'
LBIN     DS    0D          BYTE COUNT SAVE AREA FOR LABEL BYTES
LBINH    DC    F'0'
LBINL    DC    F'0'
DAIN     DS    0D          BYTE COUNT SAVE AREA FOR DATA BLOCK BYTES
DAINH    DC    F'0'
DAINL    DC    F'0'
         DC    CL8' '      Extra padding for safety
*
*    ------------------------ >   Constants for Date and Time - below
SAVE1402 DS    6F                 ONE MORE FOR SAFETY
TIMED    DS    CL7
DATED    DS    CL9
DATETIME DS    4F
         ORG   DATETIME
TIME     DS    CL4
         DS    CL4
DATE     DS    CL5
         DS    CL3
HEADDLIT DS    0CL31              Literal for headings - date and time
         DC    CL6'Today:'
         DC    CL2' '
HEADDATE DC    CL23' '
LEVELLIT DS    0CL21              Level number display for headings
         DC    CL6'Level '
LEVELL   DC    CL4'&LLEV'
         DC    CL2' ('
LEVDATE  DC    CL8' '             Assembly date for this program
         DC    CL1')'
*    ------------------------ >   Constants for Date and Time - above
         DC    F'0'               Align, just for the heck of it
GETSYSIN DC    CL80' '
OUTCARDP DC    XL80'00'           Previous card-image read
OUTCARD  DC    XL80'00'           Current  card-image read
OUTCAEND EQU   *
         DC    XL80'00'           Room for another card-image
         DS    0F
         DC    CL8' '
INAREA   DS    CL65535            Buffer to hold tape blocks
         DS    CL800              Padding, so as not to overrun
*                                 somebody else's storage by mistake.
         END
./       ADD   NAME=FOLDEM
   TITLE 'FOLDEM -- FOLD FB-80 DATA FROM A LONG BUFFER'
*  ---------------------------------------------------------------  *
*
*   AUTHOR:       Sam Golob
*
*   Copyright 2004 - 2005 by Sam Golob.  All rights reserved,
*                 subject to express permissions from the author
*                 to use this software.  This software is part
*                 of VTTS (Virtual Tape Transportation System).
*
*                 Permission is granted by the author for all
*                 parts of the VTTS package which are distributed
*                 on the CBT Tape collection, to be used by
*                 anyone for their own use, but not for resale
*                 or for reincorporation within commercial code.
*
*                           -------------------------------------
*                           It is probably not necessary to run
*                           this program in 24-bit mode.  But
*                           it works when it is run that way.
*                           -------------------------------------
*                           We do want old MVS systems to be able
*                           to run this routine.
*                           -------------------------------------
*
*  ---------------------------------------------------------------  *
*                                                                   *
*  SUBROUTINE:    FOLDEM                                            *
*                                                                   *
*  DESCRIPTION:                                                     *
*                                                                   *
*      This program is the heart of the process of creating an      *
*      AWS-format disk file from a real tape file.  The disk        *
*      file is data that has been folded over from a buffer,        *
*      into an FB-80 dataset.                                       *
*                                                                   *
*      This program takes buffer data and folds it into FB-80       *
*      data, starting from a given buffer address, for a given      *
*      number of bytes.  The data is folded into an 80-byte         *
*      workarea starting from a given OFFSET address (+0 to +79)    *
*      into the workarea.  When the workarea has been completely    *
*      filled and more data is to be written, a PUT is done to      *
*      write out the data from the 80-byte workarea, and then       *
*      the workarea is cleared with binary zeros before any         *
*      additional data is written to it.  An incompletely filled    *
*      workarea is not written out, and the same is true if the     *
*      workarea is full but no more data is to be written out.      *
*      So in that case, the location of the workarea is returned    *
*      to the caller in field FLDSCARD, and it is the caller's      *
*      responsibility to do the PUT for the last card.              *
*                                                                   *
*  INPUTS and OUTPUTS:                                              *
*                                                                   *
*      This program is driven by a control block called FLDAREA,    *
*      which is updated by both this program and by the caller.     *
*      See below for more details.                                  *
*                                                                   *
*  FILES NEEDED:                                                    *
*                                                                   *
*      This program assumes that the caller has opened DCBs for     *
*      an FB-80 file called AWSOUT, which receives the output       *
*      "virtual tape" data, and for SYSPRINT.  This program         *
*      needs to do PUTs to AWSOUT, and if necessary, it needs       *
*      to write messages to SYSPRINT.  Therefore the caller has     *
*      to provide ENTRY AWSOUT and ENTRY SYSPRINT statements in     *
*      front of its AWSOUT and SYSPRINT DCBs, respectively.         *
*                                                                   *
*  METHOD OF OPERATION:                                             *
*                                                                   *
*      This program operates using a control block, called the      *
*      FLDAREA, which is passed from the caller and back to the     *
*      caller.  Both the caller and this program update the         *
*      FLDAREA.  Upon entry to this program, R1 is expected to      *
*      point to the caller's copy of FLDAREA, and upon return,      *
*      R1 is pointed to the updated copy of FLDAREA in this         *
*      subroutine.  So the caller has to copy it back over its      *
*      own instance of FLDAREA after the return.                    *
*                                                                   *
*      The caller does one tape read, or read of data into a        *
*      buffer.  From the number of bytes read, and possibly from    *
*      the given chunk size also, the caller will construct an      *
*      AWS header which will determine how many bytes should be     *
*      folded into the FB-80 disk dataset.  This AWS header is      *
*      also folded in by a call to this program, and then the       *
*      tape data is folded in afterward, for the number of bytes    *
*      required either by the chunk size or by the block size.      *
*                                                                   *
*      This program does one or more PUTs into the FB-80 file,      *
*      until the request for the number of bytes to be folded,      *
*      is satisfied.  A PUT is done whenever the FB-80 work area    *
*      has been filled.  At the end of the fold operation, the new  *
*      OFFSET into the FB-80 workarea (that has not yet been        *
*      written out to disk), the number of bytes that have been     *
*      folded, and the projected start of the next data to be       *
*      folded, are returned in the fields of the FLDAREA control    *
*      block.                                                       *
*                                                                   *
*      The following is the layout of the FLDAREA.  Fields          *
*      marked with an arrow must be supplied upon input to this     *
*      program.                                                     *
*                                                                   *
*      FLDAREA  DS    0F         FOLDEM AREA CONTROL BLOCK          *
*      *                         ------ ---- ------- -----          *
*  --> FLDSCARD DC    F'0'       Start address of 80-byte card      *
*  --> FLDECARD DC    F'0'       End address of 80-byte card        *
*  --> FLDOFFST DC    F'0'       OFFSET of data in the card         *
*  --> FLDBYTES DC    F'0'       Number of bytes to be folded now   *
*  --> FLDBYTOT DC    F'0'       Batch total of bytes left to move  *
*      FLDBYMVD DC    F'0'       Number of bytes folded now         *
*  --> FLDBUFFR DC    F'0'       Current data start address         *
*  --> FLDBSTRT DC    F'0'       Original start data address        *
*      FLDOUTCT DC    PL7'0'     Number of PUTs for AWSOUT records  *
*  --> FLDREADF DC    X'00'      This run is "READ ONLY"  ?         *
*      *              X'01'      Yes, read only. (Copied from the   *
*                                READFLAG byte in the caller.)      *
*      FLDLENTH EQU   *-FLDAREA                                     *
*                                                                   *
*      The rest of the fields are calculated by this program        *
*      and returned to the caller.                                  *
*                                                                   *
*      FLDBUFFR and FLDOFFST are updated by this program, and       *
*      upon return to the caller, they point to the input data      *
*      and output data positions, respectively, that are just       *
*      after the moved data, to anticipate the next call, so as     *
*      to be able to move more data.  FLDBSTRT preserves the        *
*      very beginning address of the input buffer, whereas          *
*      FLDBUFFR is a place somewhere within the buffer, which       *
*      is the start from where the new data is expected to be       *
*      moved.                                                       *
*                                                                   *
*      A new field, FLDBYTOT, makes it easier to create chunked     *
*      AWS-format tape files, when the chunksize is less than       *
*      the blocksize.  This field originally (after a block is      *
*      read into the buffer from the tape) contains the number      *
*      of bytes in the entire block.  After each chunk of data      *
*      is written, this field gets decremented by the number of     *
*      bytes in the chunk just written.                             *
*                                                                   *
*      Since both the caller and this program do PUT operations     *
*      to the output FB-80 file, the count of the number of PUTs    *
*      done, FLDOUTCT, is updated by BOTH the caller and by this    *
*      program.                                                     *
*                                                                   *
*  ---------------------------------------------------------------  *
         MACRO
&NAME    HEX   &TO,&LEN,&FROM
.* ---------------------------------------------------------------  *
.*   This macro is used to display hex values in a printed report.
.* ---------------------------------------------------------------  *
&NAME    DS    0H
         ST    R4,SAVER04
         STM   15,1,HEXSAVE
         LA    1,&FROM
         LA    0,&LEN
         LA    15,&TO
         BAL   4,HEX
         L     R4,SAVER04
         LM    15,1,HEXSAVE
         MEND
         SPACE
FOLDEM   CSECT ,                                                \
         YREGS
FOLDEM   AMODE 24
FOLDEM   RMODE 24
         USING *,R15
         B     EYECATCH
         DC    C'--- '            MAKE EYECATCHER VISIBLE
         DC    C'FOLDEM'
         DC    C' - '
SYSDAT   DC    C'&SYSDATE'
         DC    C'  ',C'&SYSTIME '
SAVEAREA DC    18F'0'
EYECATCH DS    0D                    ENSURE ALIGNMENT
         STM   R14,R12,12(R13)
         LR    R5,R1                 SAVE PARM POINTER
         LA    R1,SAVEAREA           NEW SAVE-AREA ADDRESS
         ST    R1,8(,R13)            FORWARD SAVE-AREA CHAIN PTR
         ST    R13,4(,R1)            BACKWARD SAVE-AREA CHAIN PTR
         LR    R13,R1                NEW SAVE AREA ADDRESS
         DROP  R15
* -----                              SET UP BASE REGISTERS
         USING FOLDEM,R12,R11
         LR    R12,R15
         LA    R11,4095(,R12)
         LA    R11,1(,R11)
         LR    R1,R5                 RESTORE PARM POINTER
         ST    R1,SAVEPARM           Save pointer to caller's FLDAREA
         L     R0,SYSPRINV           SYSPRINT DCB address in caller
         ST    R0,SYSPRDCB             store for the program's use
         L     R0,AWSOUTV            AWSOUT   DCB address in caller
         ST    R0,AWOUTDCB             store for the program's use
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*                                                                   *
*   Routine to fold buffer data into an FB-80 file, starting at     *
*   a given location in the buffer, for a certain number of bytes,  *
*   and starting at a given OFFSET in the 80-byte workarea to       *
*   which the buffer data will be written.  When the 80-byte        *
*   workarea is filled up, a PUT is done to AWSOUT, and the         *
*   workarea is cleared with binary zeros for more data to be       *
*   written.                                                        *
*                                                                   *
*   Input:   FLDAREA fields are all supplied by the calling         *
*            program, except for FLDBYMVD which is calculated       *
*            by this program and returned to the caller.  The       *
*            caller's copy of FLDAREA is pointed to by Register 1.  *
*                                                                   *
*            The buffer area containing the data to be folded       *
*            is supplied by the calling program, as well as the     *
*            number of bytes that is expected to be folded.         *
*                                                                   *
*   Output:  Data from the buffer will be moved into the 80-byte    *
*            workarea until the workarea is filled.  When the       *
*            workarea is filled, a PUT will be done to AWSOUT,      *
*            and the workarea is cleared to X'00's to make room     *
*            for more data, when more data is to be written.        *
*                                                                   *
*            Ending OFFSET into the 80-byte workarea, pointing to   *
*            just after the data which has been moved, is returned  *
*            in the FLDOFFST field.  Upon return to the caller,     *
*            the FLDBUFFR field is updated to point to the place    *
*            in the buffer just after the data which has been       *
*            moved.  The FLDBSTRT field always should point to the  *
*            beginning of the data buffer, but this is at the       *
*            discretion of the calling program.                     *
*                                                                   *
*            A count of bytes actually moved from the buffer to     *
*            the 80-byte workarea (and written out by PUTs to the   *
*            AWSOUT DD name as is necessary) is calculated by this  *
*            program and returned in the FLDBYMVD field.  Upon      *
*            return, the number in the FLDBYMVD field should match  *
*            the number in the FLDBYTES field.                      *
*                                                                   *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
* <--------- SET UP LOOP TO START MOVING THE DATA ------->
FOLDIT   DS    0H
         L     R1,SAVEPARM          Load address of caller's FLDAREA
         L     R2,=A(FLDBLOCK)      Load address of our copy of FLDAREA
         USING FLDBLOCK,R2
         MVC   FLDAREA(FLDLENTH),0(R1)  Move caller's FLDAREA to ours
* - - - - - - - - - -      Load the buffer quantities
         L     R7,FLDBUFFR          Initialize start of buffer data
         L     R8,FLDBYTES          Bytes to be moved
         AR    R8,R7                Add in start buffer address
         ST    R8,HYPOENDB          Hypothetical end-of-buffer address
*                                   which is probably the real
*                                   end-of-data to be moved.
* - - - - - - - - - -      Load the card quantities
         MVC   SAVEBEGC,FLDSCARD    Save "start of card" address
         MVC   SAVEENDC,FLDECARD    Save "end of card" address
         MVC   FLDBYMVD,=F'0'       Initialize count of bytes moved
         L     R7,FLDSCARD          Point to beginning of card
         A     R7,FLDOFFST          Add OFFSET to start of output
         ST    R7,SAVEBEGO          Save where output starts
         L     R8,SAVEBEGO          Copy beg of output address
         A     R8,FLDBYTES          Make hypothetical end address,
*                                   by adding the bytes to be moved.
         ST    R8,HYPOENDC          Store hypothetical card end address
*                                   (This may be way past end of card.)
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
*  Cases:  1.  Current move is to within the current card.        *
*              Covered by LOOPSHRT routine.                       *
*                                                                 *
*          2.  Current move is past the current card.             *
*              Covered by LOOPMORE routine.  So we have to do     *
*              iterations.                                        *
*                                                                 *
*        R6 always contains the number of bytes to be moved       *
*        for this segment.                                        *
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
LOOPINIT DS    0H
         L     R7,SAVEBEGO          Beginning of CARD data
         L     R8,HYPOENDC          Hypothetical end of CARD data
         L     R3,FLDBUFFR          Prime R3 with start of buffer data
         C     R8,SAVEENDC          Is R8 past the end-of-card?
         BH    LOOPMORE             Yes. Do multiple moves and PUTs.
LOOPSHRT DS    0H                   No. Do the one move only.
         LR    R6,R8                Get byte count to move NOW.
         SR    R6,R7                Bytes to move from buffer to card
         C     R6,=F'80'            More than 80?
         BH    LOOPERR1             Yes. Has to be error, so flag it.
         BCTR  R6,0                 No. One less for EXECUTE.
         EX    R6,MOVEBUFF          Move the data from buffer to card.
         LA    R6,1(,R6)            Restore count of bytes moved
         L     R1,FLDBYMVD          Increment
         AR    R1,R6                  total bytes moved.
         ST    R1,FLDBYMVD          Store it away for later.
         LA    R3,0(R6,R3)          Bop past beginning buffer address.
*        MVC   LINE+1(8),=C'LSHRT1: '   **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R3,HYPOENDB          Not equal to predicted end?
         BNE   LOOPERR2             Error, so flag it.
         ST    R3,FLDBUFFR          Return modified new buffer address.
         LR    R6,R8                Calculate new OFFSET -
         S     R6,FLDSCARD          Subtract beginning of card address
         ST    R6,FLDOFFST          Store the result as new OFFSET
* -- >
LOOPTS50 DS    0H
*                                   If OFFSET > X'4F', card is complete
         C     R6,=F'80'            Is the new offset exactly X'50'?
         BNE   LOOPNT50             No. Then current card not complete.
*                                   Yes. Then PUT out card and init it.
         S     R8,=F'80'            -80 bytes because new card PUT out
         ST    R10,SAVER10          Save register for safety
         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller
         L     R1,FLDSCARD          Load address of card
         MVC   WORKAREA(80),0(R1)   Move full card image to workarea
         TM    FLDREADF,X'01'       Is this a READ only run?
         BO    NOPUT001             Yes. Can't PUT to AWSOUT.
         PUT   (10),WORKAREA        PUT the card image to output file
NOPUT001 DS    0H
         L     R10,SAVER10          Restore R10
         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written
         L     R7,SAVEBEGC          Point to beginning address of card
         MVC   0(80,R7),ZEROCARD    Initialize card image for next move
         XR    R6,R6                Clear R6
         ST    R6,FLDOFFST          New offset is 0, not X'50'
LOOPNT50 DS    0H
* -- >
         L     R1,FLDBYTOT          Before return, lessen FLDBYTOT
         S     R1,FLDBYMVD          And subtract bytes already moved
         ST    R1,FLDBYTOT          To show new total buffer byte count
*        MVC   LINE+1(8),=C'LSHRT2: '   **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         B     RETURN
*
LOOPMORE DS    0H                   Data move if more than one card
*
         L     R6,SAVEENDC          We're going past end-of-card
         SR    R6,R7                Subtract beg address of data
         C     R6,=F'80'            Still bigger than 80?
         BH    LOOPERR1             Yes. Has to be error.
         BCTR  R6,0                 Subtract one for EXECUTE
         EX    R6,MOVEBUFF          Move data into buffer
         LA    R6,1(,R6)            Restore byte count
         L     R1,FLDBYMVD          Increment
         AR    R1,R6                  total
         ST    R1,FLDBYMVD              bytes moved
         LA    R3,0(R6,R3)          Bop past data moved in buffer
*        MVC   LINE+1(8),=C'LMORE1: '  **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R3,HYPOENDB          Test if past end of buffer
         BH    LOOPERR3             Yes. Has to be an error.
         ST    R3,FLDBUFFR          Re-point current buffer address.
         S     R8,=F'80'            -80 bytes because new card PUT out
         ST    R10,SAVER10          Save register for safety
         L     R10,AWOUTDCB         Point to AWSOUT DCB in caller
         L     R1,FLDSCARD          Load address of card
         MVC   WORKAREA(80),0(R1)   Move full card image to workarea
         TM    FLDREADF,X'01'       Is this a READ only run?
         BO    NOPUT002             Yes. Then don't produce AWSOUT.
         PUT   (10),WORKAREA        PUT the card image to output file
NOPUT002 DS    0H
         L     R10,SAVER10          Restore R10
         AP    FLDOUTCT,=P'1'       Count of AWSOUT records written
         L     R7,SAVEBEGC          Point to beginning address of card
         MVC   0(80,R7),ZEROCARD    Initialize card image for next move
*        MVC   LINE+1(8),=C'LMORE2: '  **  Diagnostic  **
*        BAL   R9,FLDIMAGE
         C     R8,SAVEENDC          Is R8 within the card image end?
         BH    LOOPMORE             No. Do the LOOPMORE routine.
         B     LOOPSHRT             Yes. Do the LOOPSHRT routine.
         SPACE 3
* ----------------------------------------------------------------- *
MOVEBUFF MVC   0(*-*,R7),0(R3)      << EXECUTED >>
* --------------------------------------------------------- *
LOOPERR1 DS    0H                   Error entry location
         MVC   LINE,LINE-1             **  Diagnostic  **
         MVC   LINE+1(9),=C'LOOPERR1 '
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
LOOPERR2 DS    0H                   Error entry location
         MVC   LINE,LINE-1             **  Diagnostic  **
         MVC   LINE+1(9),=C'LOOPERR2 '
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
LOOPERR3 DS    0H                   Error entry location
         MVC   LINE,LINE-1
         MVC   LINE+1(9),=C'LOOPERR3 ' **  Diagnostic  **
         BAL   R9,FLDIMAGE
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
* --------------------------------------------------------- *
RETURN   DS    0H                   RETURN TO THE CALLER
         ST    R10,SAVER10          Save register for safety
         L     R10,SAVEPARM         Address of FLDAREA in caller
         MVC   0(FLDLENTH,R10),FLDAREA    Copy changed FLDAREA back
         L     R10,SAVER10          Restore R10
         L     R13,4(,R13)
         MVC   16(4,R13),=F'0'      Load Maximum Return Code
         MVC   24(4,R13),=A(FLDBLOCK)  Return address of FLDAREA in R1.
         LM    R14,R12,12(R13)
         BR    R14
         EJECT
* --------------------------------------------------------- *
* --------------------------------------------------------- *
* ---      S U B R O U T I N E S                        --- *
* --------------------------------------------------------- *
FLDIMAGE DS    0H         Diagnostic Data - State of FLDAREA currently
*
         HEX   LINE+10,4,FLDSCARD
         HEX   LINE+20,4,FLDECARD
         HEX   LINE+30,4,FLDOFFST
         HEX   LINE+40,4,FLDBYTES
         HEX   LINE+50,4,FLDBYTOT
         HEX   LINE+60,4,FLDBYMVD
         HEX   LINE+70,4,FLDBUFFR
         HEX   LINE+80,4,FLDBSTRT
         HEX   LINE+90,7,FLDOUTCT
         HEX   LINE+106,1,FLDREADF
         ST    R10,SAVER10          Save register for safety
         L     R10,SYSPRDCB         Point to SYSPRINT DCB in caller
         PUT   (10),LINE            PUT the print line
         MVC   LINE,LINE-1
         L     R10,SAVER10          Restore R10
         BR    R9
* - - - - - - - -  D A T A   A R E A S  - - - - - - - - *
FLDBLOCK CSECT
FLDAREA  DS    0F           FOLDEM AREA CONTROL BLOCK
*                           ------ ---- ------- -----
FLDSCARD DC    F'0'         Start address of 80-byte card
FLDECARD DC    F'0'         End address of 80-byte card
FLDOFFST DC    F'0'         OFFSET of data in the card
FLDBYTES DC    F'0'         Number of bytes to be folded now
FLDBYTOT DC    F'0'         Batch total of bytes left to move
FLDBYMVD DC    F'0'         Number of bytes folded now
FLDBUFFR DC    F'0'         Current data start address
FLDBSTRT DC    F'0'         Original start data address
FLDOUTCT DC    PL7'0'       Number of PUTs for AWSOUT records
FLDREADF DC    X'00'        This run is "READ ONLY"  ?
*              X'01'        Yes, read only.
FLDLENTH EQU   *-FLDAREA
*
FOLDEM   CSECT
WORKAREA DS    CL80                 Card image work area
         DC    CL4' '               Padding
         DC    C' '
LINE     DC    CL133' '             Output line
         DC    C' '
LINE2    DC    CL133' '             Second output line if needed
*
FF       EQU   X'FF'
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEX      DS    0H
         MVC   1(1,R15),0(R1)        Move byte
         UNPK  0(3,R15),1(2,R15)     Unpack
         TR    0(2,R15),HEXTAB-240
         LA    R15,2(,R15)           Increment output pointer
         LA    R1,1(,R1)             Increment input pointer
         BCT   R0,HEX                Decrement length, then loop
         MVI   0(R15),C' '           Blank the trailing byte
         BR    R4                    Return to caller
HEXTAB   DC    C'0123456789ABCDEF'   Translate table
         SPACE
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
HEXSAVE  DS    3F                    Register save for HEX macro
SAVER04  DS    H                     Register save for HEX macro
* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - *
ZEROCARD DC    80X'00'
SAVEBEGO DC    F'0'                 Save beg address of card output
SAVEBEGC DC    F'0'                 Save beg address of card
SAVEENDC DC    F'0'                 Save end address of card
SAVEPARM DC    F'0'                 Save CALLER'S FLDAREA address
HYPOENDC DC    F'0'                 Hypothetical end address after card
HYPOENDB DC    F'0'                 Calculated end of buffer address
SYSPRINV DC    V(SYSPRINT)          Address of SYSPRINT DCB
AWSOUTV  DC    V(AWSOUT)            Address of AWSOUT DCB
SYSPRDCB DC    F'0'                 SYSPRINT DCB address stored here
AWOUTDCB DC    F'0'                 AWSOUT DCB address stored here
SAVER10  DC    F'0'
         END
//C.SYSIN  DD  *
* TESTPGM: VTT2TAPE UNFOLDEM
TESTPGM: VTT2DISK FOLDEM
//G.SYSPRINT DD SYSOUT=*
//G.SYSUDUMP DD SYSOUT=*
//TAPIN    DD  DISP=OLD,UNIT=480,VOL=SER=EXHDTR,
//             LABEL=(1,BLP,EXPDT=98000)
//AWSOUT   DD  DSN=&&DUMP,
//             DISP=(NEW,PASS),UNIT=SYSDA,
//             SPACE=(CYL,(30,30),RLSE),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=8000)
//AWSIN    DD  DISP=SHR,DSN=GERHARD.MVS.SZAP.HET
//TAPOUT   DD  DISP=(,PASS),DSN=&&TEMP,
//             UNIT=SYSDA,SPACE=(CYL,(1,1))
//*
//       EXEC  PGM=PRINTALL,PARM='100,RD'
//SYSPRINT DD  SYSOUT=*
//SYSUT2   DD  DISP=(OLD,DELETE),DSN=&&TEMP
//SYSUT1   DD  DISP=(OLD,DELETE),DSN=&&DUMP
//
